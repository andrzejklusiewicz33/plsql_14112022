select * from employees;
--przerwa do 10:43
--blok anonimowy
--procedura
--funkcja
--trigger / wyzwalacz
--pakiet 
/
begin
null;
end;
/
begin
dbms_output.put_line('hello world!');
end;
/
set serveroutput on;
/

declare
owoc varchar2(4000);
x integer;
y number;
z date;
begin
dbms_output.put_line('hello world!');
end;
/


declare
owoc varchar2(4000):='banan';
x integer:=200;
y number;
z date;
begin
x:=100;
dbms_output.put_line('hello world! owoc='||owoc||' x='||x);
end;
/

/*1.
Stwórz blok anonimowy który przyjmie poprzez zmienne twoje imie oraz nazwisko, 
a nastepnie wyswietli komunikat typu witaj twoje_imie twoje_nazwisko!
*/

--first_name
--firstName


declare
first_name varchar2(4000):='Andrzej';
last_name varchar2(4000):='Klusiewicz';
begin
dbms_output.put_line('Witaj '||first_name||' '||last_name||'!');
end;
/


declare
first_name varchar2(4000);
last_name varchar2(4000);
begin
firsT_name:='Andrzej';
last_name:='Klusiewicz';
dbms_output.put_line('Witaj '||first_name||' '||last_name||'!');
end;
/

declare
x integer:=10;
y integer:=3;
begin
dbms_output.put_line(x/y);
end;
/


declare
x integer:=10;
y integer:=3;
wynik number:=x/y;
begin
dbms_output.put_line(wynik);
end;
/


declare
x integer:=10;
y integer:=3;
wynik number;
begin
wynik:=round(x/y,2);
dbms_output.put_line(wynik);
end;
/


declare
x integer:=10;
y integer:=6;
wynik number;
begin
wynik:=round(x/y,2);
dbms_output.put_line(wynik);
end;
/


declare
x integer:=10;
y integer:=6;
wynik number;
begin
wynik:=trunc(x/y,2);
dbms_output.put_line(wynik);
end;
/

/*2.
napisz program który przyjmie przez zmienne wzrost w metrach i masê w kilogramach a nastepnie 
wyliczy i wypisze zaokraglone do 2 miejsc po przecinku bmi wg. wzoru masa/(wzrost*wzrost)
*/

select 72/power(1.76,2) from dual;
/

declare
wzrost number:=1.76;
masa number:=72;
bmi number:=round(masa/power(wzrost,2),2);
begin
dbms_output.put_line('Twoje BMI='||bmi||' (grubasie!)');
end;

/

declare
wzrost number:=1.76;
masa number:=72;
bmi number;
begin
bmi:=round(masa/power(wzrost,2),2);
dbms_output.put_line('Twoje BMI='||bmi||' (grubasie!)');
end;

/



declare
wzrost number:=0;
masa number:=72;
bmi number;
begin
bmi:=round(masa/power(wzrost,2),2);
dbms_output.put_line('Twoje BMI='||bmi||' (grubasie!)');
exception 
when zero_divide then dbms_output.put_line('wzrost jest równy zero!');
end;
/

declare
wzrost number:=0;
masa number:=72;
bmi number:=round(masa/power(wzrost,2),2);
begin
dbms_output.put_line('Twoje BMI='||bmi||' (grubasie!)');
exception 
when zero_divide then dbms_output.put_line('wzrost jest równy zero!');
end;
/

create or replace procedure hello is 
begin
dbms_output.put_line(1/0);
end;
/

execute hello;
/



declare
wzrost number:=1.76;
masa number:=72;
bmi integer:=round(masa/power(wzrost,2),2); -----fuuuuuu - zaokr¹glanie do calosci nastepuje!
begin
dbms_output.put_line('Twoje BMI='||bmi||' (grubasie!)');
exception 
when zero_divide then dbms_output.put_line('wzrost jest równy zero!');
end;
/

declare
x integer:=1;
begin
if x=1 then
    dbms_output.put_line('jeden!');
    dbms_output.put_line('jeden!');
    dbms_output.put_line('jeden!');
end if;
dbms_output.put_line('koniec');
end;
/


declare
x integer:=2;
begin
if x=1 then
    dbms_output.put_line('jeden!');    
else 
    dbms_output.put_line('nie jeden!');
end if;
dbms_output.put_line('koniec');
end;
/



declare
x integer:=1;
begin
if x=1 then
    dbms_output.put_line('jeden!');    
    dbms_output.put_line('jeden!');    
    dbms_output.put_line('jeden!');    
elsif x=2 then
    dbms_output.put_line('dwa!');
elsif x=3 then 
    dbms_output.put_line('trzy!');
else 
    dbms_output.put_line('albo mniej niz jeden, albo wiecej niz trzy');
end if;
dbms_output.put_line('koniec');
end;
/


declare --fuuuuuu
x integer:=2;
begin
if x=1 then
    dbms_output.put_line('jeden!');    
end if;    
if x=2 then
    dbms_output.put_line('dwa!');
end if;
if x=3 then 
    dbms_output.put_line('trzy!');
end if;
dbms_output.put_line('koniec');
end;
/

/*3.
*. Napisz blok anonimowy który przyjmie przez zmienn¹ wartoœæ liczbow¹ i wypisze czy wartoœæ ta jest mniejsza, równa czy wiêksza ni¿ 0.
*/

declare
x integer:=-10;
begin
if x>0 then 
    dbms_output.put_line('liczba dodatnia');
elsif x=0 then 
    dbms_output.put_line('zero!');
elsif x<0 then 
    dbms_output.put_line('liczba ujemna');
end if;    
end;
/
--if x>0{
--    
--}
/

declare
x integer:=-10;
begin
if x>0 then 
    dbms_output.put_line('liczba dodatnia');
elsif x=0 then 
    dbms_output.put_line('zero!');
else  
    dbms_output.put_line('liczba ujemna');
end if;    
end;
/

--przerwa do 12:00


/*
5. Napisz program który przyjmie od uzytkownika (przez zmienne) jego wzrost i masê, obliczy bmi i wyswietli stosowny opis wg. Wikipedii
*/

declare
wzrost number:=1.76;
masa number:=72;
bmi number;
begin
bmi:=round(masa/power(wzrost,2),2);
dbms_output.put_line('Twoje BMI='||bmi||' (grubasie!)');
end;
/
--https://pl.wikipedia.org/wiki/Wska%C5%BAnik_masy_cia%C5%82a


declare
wzrost number:=1.76;
masa number:=72;
bmi number;
begin
bmi:=round(masa/power(wzrost,2),2);
dbms_output.put_line('Twoje BMI='||bmi||' (grubasie!)');
if bmi<16 then
    dbms_output.put_line('wyglodzenie');
elsif bmi>=16 and bmi<17 then ---fuuuuuu
    dbms_output.put_line('wychudzenie');
end if;
end;
/



declare
wzrost number:=1.76;
masa number:=93;
bmi number;
begin
bmi:=round(masa/power(wzrost,2),2);
dbms_output.put_line('Twoje BMI='||bmi||' (grubasie!)');
if bmi<16 then
    dbms_output.put_line('wyglodzenie');
elsif bmi<17 then 
    dbms_output.put_line('wychudzenie');
elsif bmi<18.5 then 
    dbms_output.put_line('niedowaga');
elsif bmi<25 then 
    dbms_output.put_line('masa ok');
elsif bmi<30 then
    dbms_output.put_line('nadwaga');
elsif bmi<35 then
    dbms_output.put_line('I stopieñ przypakowania');
elsif bmi<40 then 
    dbms_output.put_line('II stopieñ przypakowania');
else 
    dbms_output.put_line('III stopieñ przypakowania');
end if;
end;
/


begin
    for x in 1..10 loop
    dbms_output.put_line('siema');
    end loop;
    dbms_output.put_line('koniec');
end;
/




begin
    for x in 1..10 loop
        dbms_output.put_line('siema po raz '||x);
    end loop;
    dbms_output.put_line('koniec');
end;
/

/*Zadanie 6.
*. Wyœwietl 20 kolejnych potêg liczby 2
*/

select power(10,3) from dual;
/

begin
for koza in 1..20 loop
    dbms_output.put_line('2^'||koza||'='||power(2,koza));
end loop;
end;
/


declare
wynik number;
begin
for koza in 1..20 loop
    wynik:=power(2,koza);
    dbms_output.put_line('2^'||koza||'='||wynik);
end loop;
end;

/


declare
wynik number;
x integer;
begin
for koza in 1..20  loop
    x:=koza*2;
    wynik:=power(2,x);
    dbms_output.put_line('2^'||x||'='||wynik);
end loop;
end;
/


declare
wynik number;
x integer;
begin
for koza in 20..1  loop --fuuuu
    x:=koza*2;
    wynik:=power(2,x);
    dbms_output.put_line('2^'||x||'='||wynik);
end loop;
end;
/


declare
wynik number;
begin
for koza in  reverse 1..20  loop --fuuuu
    wynik:=power(2,koza);
    dbms_output.put_line('2^'||koza||'='||wynik);
end loop;
end;
/


begin
for x in  -10..10 loop
    if x<0 then
        dbms_output.put_line(x||' jest mniejsze od 0');
    elsif x=0 then 
        dbms_output.put_line(x||' jest zerem');
    else 
        dbms_output.put_line(x||' jest wiêksze od 0');
    end if;
end loop;
end;

/*
7. Wypisz liczby w zakresie 1-100 obok kazdej piszac czy jest parzysta czy nie
*/

select mod(11,2) from dual;
/

begin
for x in 1..100 loop
    if mod(x,2)=0 then 
        dbms_output.put_line(x||' jest parzysta');
    else
        dbms_output.put_line(x||' jest nieparzysta');
    end if;
end loop;
end;
/

--przerwa obiadowa do 13:24

/*
8. Napisz symulator lokaty. Symulator ma przez zmienne przyjac kwote lokowana, ilosc miesiecy 
na ktora zakladamy lokatê i oprocentowanie w skali roku. Zakladamy comiesieczna kapitalizacje 
odsetek. Dla kazdego miesiaca trwania lokaty wyswietl ktory to miesiac i ile mamy odlozone na 
lokacie. 
*/

declare
konto number:=100000;
ilosc_miesiecy integer:=24;
oprocentowanie number:=0.08;
begin
    for m in 1..ilosc_miesiecy loop
        konto:=round(konto+(konto*oprocentowanie/12),2);
        dbms_output.put_line(m||' '||konto);
    end loop;
end;
/


declare
konto number:=100000;
ilosc_miesiecy integer:=24;
oprocentowanie number:=-0.18;
begin
    for m in 1..ilosc_miesiecy loop
        konto:=round(konto+(konto*oprocentowanie/12),2);
        dbms_output.put_line(m||' '||konto);
    end loop;
end;
/

begin
for x in -10..10 loop
    if x=0 then
        continue;
    end if;
    dbms_output.put_line(x||' '||1/x);
end loop;
end;
/

begin
for x in -10..10 loop
    if x=0 then
        exit;
    end if;
    dbms_output.put_line(x||' '||1/x);
end loop;
end;
/


begin
while(1=1) loop
    null;
end loop;
end;
/


declare
suma integer:=1;
x integer:=1;
begin
while(suma<100) loop
    x:=x+1;
    suma:=suma+x;
    dbms_output.put_line('x='||x||' suma='||suma);
end loop;
end;
/


declare 
cursor k is select * from employees;
begin
for w in k loop
    dbms_output.put_line(w.last_name);
end loop;
end;
/

declare
x integer:=0;
begin
loop
x:=x+1;
dbms_output.put_line(x);
exit when x=10;
end loop;
end;

/


declare
x integer:=0;
begin
loop
x:=x+1;
dbms_output.put_line(x);
if x=10 then exit;
end if;
end loop;
end;
/

/*9.
Korzystajac z petli while lub exit when wyswietlaj kolejne potegi liczby dwa az potega nie wyniesie wiecej niz 10000
*/


declare
wynik number:=0;
np integer:=0;
begin
while(wynik<10000) loop
    np:=np+1;
    wynik:=power(2,np);
    dbms_output.put_line(np||' '||wynik);
end loop;
end;
/


declare
wynik number:=0;
np integer:=0;
begin
while(wynik<10000) loop
    dbms_output.put_line(np||' '||wynik);
    np:=np+1;
    wynik:=power(2,np);    
end loop;
end;
/

declare
wynik number:=0;
np integer:=0;
begin
loop
np:=np+1;
wynik:=power(2,np);
exit when wynik>10000;
dbms_output.put_line(wynik);
end loop;
end;
/


/*10.
Napisz program który bêdzie dodawa³ kolejne wartoœci losowe do sumy (wypisuj¹c ile doda³ i ile wynosi suma)
tak d³ugo a¿ suma nie przekroczy wartoœci podanej przez u¿ytkownika (przez zmienna). Wartoœæ losowa:
execute dbms_output.put_line(round(dbms_random.value(1,1000)));
*/


execute dbms_output.put_line(round(dbms_random.value(1,1000)));
/
declare
wylosowane number;
begin
wylosowane:=round(dbms_random.value(1,1000));
dbms_output.put_line(wylosowane);
end;
/

declare
suma number:=0;
maksimum integer:=1000;
begin
while suma<=maksimum loop
    suma:=suma+round(dbms_random.value(1,10));
    dbms_output.put_line(suma);
end loop;
end;
/

declare
suma number:=0;
maksimum integer:=1000;
begin
loop
    suma:=suma+round(dbms_random.value(1,10));
    exit when suma>maksimum ;
    dbms_output.put_line(suma);
end loop;
end;
/
declare
suma number:=0;
maksimum integer:=1000;
begin
while suma<=maksimum loop
    dbms_output.put_line(suma);
    suma:=suma+round(dbms_random.value(1,10));    
end loop;
end;
/


declare
suma number:=0;
maksimum integer:=1000;
begin
loop
    suma:=suma+round(dbms_random.value(1,10));    
    if suma>maksimum then exit;
    end if;    
    dbms_output.put_line(suma);
end loop;
end;
/

--przerwa do 14:44

begin
execute immediate 'create index ';
end;
/

select * from employees;

begin
update employees set commission_pct=0.5 where department_id=90;
end;
/

declare
prowizja number:=0.5;
departament integer:=90;
begin
update employees set commission_pct=prowizja where department_id=departament;
end;
/

rollback;
/

declare
prowizja number:=0.5;
departament integer:=90;
begin
update employees set commission_pct=prowizja where department_id=departament;
commit;
end;
/

update employees set salary=1000 where department_id=1;

/
declare
prowizja number:=0.5;
departament integer:=90;
begin
update employees set commission_pct=prowizja where department_id=departament;
dbms_output.put_line('zmiana dotyczyla '||sql%rowcount||' wierszy');
commit;
end;
/

declare
prowizja number:=0.5;
departament integer:=900;
begin
update employees set commission_pct=prowizja where department_id=departament;
dbms_output.put_line('zmiana dotyczyla '||sql%rowcount||' wierszy');
if sql%rowcount=0 then 
    dbms_output.put_line('NIE ZMIENIONO ¯ADNEGO WIERSZA!');
end if;
commit;
end;
/



declare
prowizja number:=0.5;
departament integer:=90;
begin
update employees set commission_pct=prowizja where department_id=departament;
commit;
dbms_output.put_line('zmiana dotyczyla '||sql%rowcount||' wierszy');
end;
/

DECLARE
WIERSZ EMPLOYEES%rowtype;
BEGIN
wiersz.last_name:='Klusiewicz';
dbms_output.put_line(wiersz.last_name);
END;
/

/*11.
Napisz program ktory bedzie dawal podwyzki. Kwota podwyzki oraz numer departamentu dla ktorego 
zostanie zastosowana podwyzka maja zostac podane przez uzytkownika (POPRZEZ ZMIENNE).
Operacja ma byæ zatwierdzona transakcyjnie a na konsoli chcemy jeszcze wyswietlic ilu wierszy dotyczyla zmiana.
*/


desc employees;

alter table employees enable row movement;
flashback table employees to timestamp to_timestamp('14-11-2022 14:00:00','dd-mm-yyyy hh24:mi:ss');
/

declare 
ile number:=1000;
nr_departamentu integer:=90;
begin
update employees set salary=salary+ile where department_id=nr_departamentu;
dbms_output.put_line('zmieniono '||sql%rowcount||' wierszy');
commit;
end;
/


create table owoce(
nr_owocu integer primary key,
nazwa_owocu varchar2(4000)
);


insert into owoce values (1,'Banan');
insert into owoce values (2,'Mandarynka');
select * from owoce;

create sequence moja;

select moja.nextval from dual;

create sequence owocowa start with 3 ;
create sequence owocowa start with 3 increment by 1;

insert into owoce values (owocowa.nextval,'XXXXX');
select * from owoce;


create sequence faktury_seq;

create table faktury (
id_faktury integer primary key,
numer_faktury varchar2(4000)
);

create table produkty_na_fakturach (
id_pnf integer primary key,
nazwa varchar2(4000),
id_faktury integer references faktury(id_faktury)
);

begin
insert into faktury values (faktury_seq.nextval,'01/01/2022');
insert into produkty_na_fakturach values (faktury_seq.nextval,'Bulbulator',);
end;

select owocowa.currval from dual;
select owocowa.nextval from dual;
/

declare
id integer;
begin
id:=faktury_seq.nextval;
insert into faktury values (id,'01/01/2022');
insert into produkty_na_fakturach values (faktury_seq.nextval,'Bulbulator',id);
end;

select * from faktury;
select * from produkty_na_fakturach;



declare
id integer;
begin
insert into faktury values (faktury_seq.nextval,'01/01/2022') returning id_faktury into id;
insert into produkty_na_fakturach values (faktury_seq.nextval,'Bulbulator',id);
commit;
end;
/

select * from regions;
/*12.
Napisz program ktory bedzie dodawal wiersze do tabeli regions. Nazwa regionu ma zostac podana przez 
uzytkownika (przez zmienn¹). Numer regionu ma zostac podany z sekwencji a nastepnie po zapisie wiersza wyswietlony na konsoli.
(Chcemy uzyskac region_id pod jakim wyladowal nowo dodany region)
*/

create sequence reg_seq start with 5;

insert into regions values (reg_seq.nextval,'Sosnowiec');

CREATE SEQUENCE regio start with 5 ;
/

select * from user_sequences;



delete from regions where region_id=5;

create sequence rseq start with 5;

declare
nazwa varchar2(4000):='Sosnowiec';
id integer;
begin
insert into regions(region_id,region_name) values (rseq.nextval, nazwa) returning region_id into id;
dbms_output.put_line('Region '||nazwa||' jest pod id='||id);
end;

insert into regions values (5,'xxx');
insert into regions(region_id,region_name) values (5,'xxxx');

/
declare
nazwa varchar2(4000):='&nazwa_regionu';
id integer;
begin
insert into regions(region_id,region_name) values (rseq.nextval, nazwa) returning region_id into id;
dbms_output.put_line('Region '||nazwa||' jest pod id='||id);
end;
/

declare
najwyzszy integer:=4;
begin
delete from regions where region_id>najwyzszy;
end;
/

select * from regions;

/
declare
nazwisko varchar2(4000);
begin
select last_name into nazwisko from employees where employee_id=198;
dbms_output.put_line(nazwisko);
end;
/
declare
nazwisko varchar2(4000);
imie varchar2(4000);
begin
select last_name,first_name into nazwisko,imie from employees where employee_id=198;
dbms_output.put_line(nazwisko);
dbms_output.put_line(imie);
end;
/



declare
nazwisko varchar2(4000);
imie varchar2(4000);
begin
select last_name,first_name into nazwisko,imie from employees; --fuuu
dbms_output.put_line(nazwisko);
dbms_output.put_line(imie);
end;

/

declare
srednia number;
ilosc integer;
begin
select round(avg(salary)),count(*) into srednia,ilosc from employees;
dbms_output.put_line(srednia);
dbms_output.put_line(ilosc);
dbms_output.put_line(srednia||' '||ilosc);
end;
/
select avg(salary),count(*) from employees;
/


/*13.
 Wczytaj do zmiennej a nastêpnie wyœwietl iloœæ osób w departamencie którego numer zostanie podany 
przez uzytkownika
*/
--
--declare
--x integer:=&something;
--begin
--null;
--end;

declare
nr_departamentu integer:=&numer_departamentu;
ilosc integer;
begin
select count(*) into ilosc from employees where department_id=nr_departamentu;
dbms_output.put_line(ilosc);
end;

/


/*14.
Wczytaj do zmiennych i wyœwietl w osobnych liniach imiê, nazwisko i telefon osoby której numer pracownika poda u¿ytkownik.
*/


declare ---fuuuuuuu zle bo trzy odwolania do tabeli
imie varchar2(4000);
nazwisko varchar2(4000);
telefon varchar2(4000);
id integer:=&numer_pracownika;
begin
select first_name into imie from employees where employee_id=id;
select last_name into nazwisko from employees where employee_id=id;
select phone_number into telefon from employees where employee_id=id;
dbms_output.put_line(imie);
dbms_output.put_line(nazwisko);
dbms_output.put_line(telefon);
end;

/


declare
imie varchar2(4000);
nazwisko varchar2(4000);
telefon varchar2(4000);
id integer:=&numer_pracownika;
begin
select first_name,last_name,phone_number into imie,nazwisko,telefon from employees where employee_id=id;
dbms_output.put_line(imie);
dbms_output.put_line(nazwisko);
dbms_output.put_line(telefon);
end;


/
select * from employees;
/
declare
wiersz employees%rowtype;
begin
select * into wiersz from employees where employee_id=1;
exception
when no_data_found then dbms_output.put_line('nie znaleziono wiersza o takim id');
end;
/

declare
wiersz employees%rowtype;
begin
select * into wiersz from employees where employee_id=1;
exception
when others then dbms_output.put_line(sqlerrm);
end;
/


select * from employees where employee_id=100;
select first_name from employees where employee_id=100;

--blob,clob,nclob

/

/*15.
Wczytaj do zmiennej i wyœwietl na konsoli ró¿nicê pomiêdzy najwy¿szymi i najni¿szymi zarobkami 
w departamencie którego nazwê przekaze u¿ytkownik. Program ma byæ niewra¿liwy na wielkoœæ liter 
w nazwie departamentu.
*/

select * from employees;
select * from departments;

select * from departments where lower(department_name)=lower('MARKETING');

SELECT MAX(SALARY)-MIN(SALARY) FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID) WHERE lower(DEPARTMENT_NAME)=lower('It');

select max(salary)-min(salary) from employees where department_id=(select department_id from departments where lower(department_name)=lower('it'));

declare
nazwa_departamentu varchar2(4000):='&nazwa_departamentu';
roznica number;
begin
select max(salary)-min(salary) into roznica from employees where department_id=(select department_id from departments where lower(department_name)=lower(nazwa_departamentu));
dbms_output.put_line('ró¿nica p³ac dla departamentu '||nazwa_departamentu||' wynosi '||roznica);
end;
/

SELECT MAX(SALARY)-MIN(SALARY) FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID) WHERE lower(DEPARTMENT_NAME)=lower('It');

select max(salary)-min(salary) from employees where department_id=(select department_id from departments where lower(department_name)=lower('it'));
/

alter session set tracefile_identifier='to_ja_jestem_plikiem_ktorego_szukasz';
alter session set sql_trace=true;

create table wielka as select * From employees;

begin
for x in 1..14 loop
 insert into wielka select * from wielka;
 commit;
end loop;
end;

declare
cursor k is 
select * from wielka order by last_name;
begin
for w in k loop
null;
end loop;
end;
/

select 504069/17595097 from dual;

--przerwa do 10:29
/

declare
wiersz departments%rowtype;
begin
wiersz.department_name:='Coœtam';
dbms_output.put_line(wiersz.department_name);
end;
/

select * from departments;
/

declare
wiersz departments%rowtype;
begin
select * into wiersz from departments where department_id=90;
dbms_output.put_line(wiersz.department_name);
end;
/


declare
wiersz departments%rowtype;
begin
select * into wiersz from departments where department_id=90;
dbms_output.put_line(upper(wiersz.department_name));
end;
/



/*16.
Wczytaj do zmiennej caly wiersz pracownika ktorego numer poda uzytkownik. Nastepnie wyswietl
na konsoli imie, nazwisko, wynagrodzenie i datê zatrudnienia pracownika w formacie dd-mm-yyyy z wiersza.
*/


select * from employees;
select to_char(sysdate,'dd-mm-yyyy'),sysdate from dual;

alter SESSION  set NLS_DATE_FORMAT = 'dd-mm-yyyy';
/
declare
wiersz employees%rowtype;
nr_pracownika integer:=&numer_pracownika;
begin
select * into wiersz from employees where employee_id=nr_pracownika;
dbms_output.put_line(wiersz.first_name);
dbms_output.put_line(wiersz.last_name);
dbms_output.put_line(wiersz.salary);
dbms_output.put_line(to_char(wiersz.hire_date,'dd-mm-yyyy'));
end;

/

execute dbms_output.put_line('coœ'||chr(13)||'coœ jeszcze');
/


declare
type rekordowy is record(
 nazwisko varchar2(4000),
 departament varchar2(4000)
);
rek rekordowy;
begin
select last_name,department_name into rek from employees join departments using(department_id) where employee_id=100;
dbms_output.put_line(rek.nazwisko);
dbms_output.put_line(rek.departament);
end;
/



declare
type rekordowy is record(
 nazwisko employees.last_name%type,
 departament varchar2(4000)
);
rek rekordowy;
begin
select last_name,department_name into rek from employees join departments using(department_id) where employee_id=100;
dbms_output.put_line(rek.nazwisko);
dbms_output.put_line(rek.departament);
end;
/

desc employees;
/

/*17.
Wczytaj do zmiennej typu rekordowego zaokraglona srednia, minimum i maksimum zarobkow
w departamencie ktorego numer zostanie podany przez uzytkownika. Wczytane dane wyswietl na konsoli
*/

declare
type rekordowy is record(
srednia number,
minimum number,
maksimum number
);
rek rekordowy;
begin
select round(avg(salary)),min(salary),max(salary) into rek from employees where department_id=&numer_departamentu;
dbms_output.put_line('srednia='||rek.srednia);
dbms_output.put_line('minimum='||rek.minimum);
dbms_output.put_line('maksimum='||rek.maksimum);
end;
/

declare
cursor k is select * from employees;
begin
for w in k loop
    dbms_output.put_line(w.first_name||' '||w.last_name);
end loop;
end;
/


declare
cursor k is select first_name,last_name from employees;
begin
for w in k loop
    dbms_output.put_line(w.first_name||' '||w.last_name);
end loop;
end;
/

select * from employees;
drop index emp_name_ix;
select firsT_name,last_name from employees;
create index omg_wtf on employees(last_name,first_name);

select * from employees where department_id=90;

create index abc on employees(department_id);

select department_id,rowid from employees order by 1;
select * from employees where rowid in  ('AAAR6YAAEAAALBeAAE','AAAR6YAAEAAALBeAAD');
/



declare
cursor k is 
select first_name,last_name,job_title from employees join jobs using(job_id);
begin
for w in k loop
    dbms_output.put_line(w.first_name||' '||w.last_name||' '||w.job_title);
end loop;
end;
/


begin
 for w in (select last_name from employees) loop
    dbms_output.put_line(w.last_name);
 end loop;
end;
/


declare
cursor k is 
select first_name,last_name,job_title from employees join jobs using(job_id);
begin
for w in k loop
    dbms_output.put_line(w.first_name||' '||w.last_name||' '||w.job_title);
end loop;
end;
/

declare
cursor k is 
select first_name,last_name,job_title from employees join jobs using(job_id);
w k%rowtype;
begin
open k;
loop
    fetch k into w;
    exit when k%notfound;
    dbms_output.put_line(w.first_name||' '||w.last_name||' '||w.job_title);
end loop;    
close k;
end;
/

declare
cursor k is select * from employees;
type tablica is table of k%rowtype index by binary_integer;
tab tablica;
begin
open k;
fetch k bulk collect into tab;
close k;
dbms_output.put_line(tab.count);
end;
/


/*18.
Korzystajac z kursora wyœwietl na konsoli nazwiska, daty zatrudnienia w formacie dd-mm-yyyy
 i nazwy departamentów wszystkich pracowników
*/