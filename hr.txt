select * from employees;
--przerwa do 10:43
--blok anonimowy
--procedura
--funkcja
--trigger / wyzwalacz
--pakiet 
/
begin
null;
end;
/
begin
dbms_output.put_line('hello world!');
end;
/
set serveroutput on;
/

declare
owoc varchar2(4000);
x integer;
y number;
z date;
begin
dbms_output.put_line('hello world!');
end;
/


declare
owoc varchar2(4000):='banan';
x integer:=200;
y number;
z date;
begin
x:=100;
dbms_output.put_line('hello world! owoc='||owoc||' x='||x);
end;
/

/*1.
Stwórz blok anonimowy który przyjmie poprzez zmienne twoje imie oraz nazwisko, 
a nastepnie wyswietli komunikat typu witaj twoje_imie twoje_nazwisko!
*/

--first_name
--firstName


declare
first_name varchar2(4000):='Andrzej';
last_name varchar2(4000):='Klusiewicz';
begin
dbms_output.put_line('Witaj '||first_name||' '||last_name||'!');
end;
/


declare
first_name varchar2(4000);
last_name varchar2(4000);
begin
firsT_name:='Andrzej';
last_name:='Klusiewicz';
dbms_output.put_line('Witaj '||first_name||' '||last_name||'!');
end;
/

declare
x integer:=10;
y integer:=3;
begin
dbms_output.put_line(x/y);
end;
/


declare
x integer:=10;
y integer:=3;
wynik number:=x/y;
begin
dbms_output.put_line(wynik);
end;
/


declare
x integer:=10;
y integer:=3;
wynik number;
begin
wynik:=round(x/y,2);
dbms_output.put_line(wynik);
end;
/


declare
x integer:=10;
y integer:=6;
wynik number;
begin
wynik:=round(x/y,2);
dbms_output.put_line(wynik);
end;
/


declare
x integer:=10;
y integer:=6;
wynik number;
begin
wynik:=trunc(x/y,2);
dbms_output.put_line(wynik);
end;
/

/*2.
napisz program który przyjmie przez zmienne wzrost w metrach i masê w kilogramach a nastepnie 
wyliczy i wypisze zaokraglone do 2 miejsc po przecinku bmi wg. wzoru masa/(wzrost*wzrost)
*/

select 72/power(1.76,2) from dual;
/

declare
wzrost number:=1.76;
masa number:=72;
bmi number:=round(masa/power(wzrost,2),2);
begin
dbms_output.put_line('Twoje BMI='||bmi||' (grubasie!)');
end;

/

declare
wzrost number:=1.76;
masa number:=72;
bmi number;
begin
bmi:=round(masa/power(wzrost,2),2);
dbms_output.put_line('Twoje BMI='||bmi||' (grubasie!)');
end;

/



declare
wzrost number:=0;
masa number:=72;
bmi number;
begin
bmi:=round(masa/power(wzrost,2),2);
dbms_output.put_line('Twoje BMI='||bmi||' (grubasie!)');
exception 
when zero_divide then dbms_output.put_line('wzrost jest równy zero!');
end;
/

declare
wzrost number:=0;
masa number:=72;
bmi number:=round(masa/power(wzrost,2),2);
begin
dbms_output.put_line('Twoje BMI='||bmi||' (grubasie!)');
exception 
when zero_divide then dbms_output.put_line('wzrost jest równy zero!');
end;
/

create or replace procedure hello is 
begin
dbms_output.put_line(1/0);
end;
/

execute hello;
/



declare
wzrost number:=1.76;
masa number:=72;
bmi integer:=round(masa/power(wzrost,2),2); -----fuuuuuu - zaokr¹glanie do calosci nastepuje!
begin
dbms_output.put_line('Twoje BMI='||bmi||' (grubasie!)');
exception 
when zero_divide then dbms_output.put_line('wzrost jest równy zero!');
end;
/

declare
x integer:=1;
begin
if x=1 then
    dbms_output.put_line('jeden!');
    dbms_output.put_line('jeden!');
    dbms_output.put_line('jeden!');
end if;
dbms_output.put_line('koniec');
end;
/


declare
x integer:=2;
begin
if x=1 then
    dbms_output.put_line('jeden!');    
else 
    dbms_output.put_line('nie jeden!');
end if;
dbms_output.put_line('koniec');
end;
/



declare
x integer:=1;
begin
if x=1 then
    dbms_output.put_line('jeden!');    
    dbms_output.put_line('jeden!');    
    dbms_output.put_line('jeden!');    
elsif x=2 then
    dbms_output.put_line('dwa!');
elsif x=3 then 
    dbms_output.put_line('trzy!');
else 
    dbms_output.put_line('albo mniej niz jeden, albo wiecej niz trzy');
end if;
dbms_output.put_line('koniec');
end;
/


declare --fuuuuuu
x integer:=2;
begin
if x=1 then
    dbms_output.put_line('jeden!');    
end if;    
if x=2 then
    dbms_output.put_line('dwa!');
end if;
if x=3 then 
    dbms_output.put_line('trzy!');
end if;
dbms_output.put_line('koniec');
end;
/

/*3.
*. Napisz blok anonimowy który przyjmie przez zmienn¹ wartoœæ liczbow¹ i wypisze czy wartoœæ ta jest mniejsza, równa czy wiêksza ni¿ 0.
*/

declare
x integer:=-10;
begin
if x>0 then 
    dbms_output.put_line('liczba dodatnia');
elsif x=0 then 
    dbms_output.put_line('zero!');
elsif x<0 then 
    dbms_output.put_line('liczba ujemna');
end if;    
end;
/
--if x>0{
--    
--}
/

declare
x integer:=-10;
begin
if x>0 then 
    dbms_output.put_line('liczba dodatnia');
elsif x=0 then 
    dbms_output.put_line('zero!');
else  
    dbms_output.put_line('liczba ujemna');
end if;    
end;
/

--przerwa do 12:00


/*
5. Napisz program który przyjmie od uzytkownika (przez zmienne) jego wzrost i masê, obliczy bmi i wyswietli stosowny opis wg. Wikipedii
*/

declare
wzrost number:=1.76;
masa number:=72;
bmi number;
begin
bmi:=round(masa/power(wzrost,2),2);
dbms_output.put_line('Twoje BMI='||bmi||' (grubasie!)');
end;
/
--https://pl.wikipedia.org/wiki/Wska%C5%BAnik_masy_cia%C5%82a


declare
wzrost number:=1.76;
masa number:=72;
bmi number;
begin
bmi:=round(masa/power(wzrost,2),2);
dbms_output.put_line('Twoje BMI='||bmi||' (grubasie!)');
if bmi<16 then
    dbms_output.put_line('wyglodzenie');
elsif bmi>=16 and bmi<17 then ---fuuuuuu
    dbms_output.put_line('wychudzenie');
end if;
end;
/



declare
wzrost number:=1.76;
masa number:=93;
bmi number;
begin
bmi:=round(masa/power(wzrost,2),2);
dbms_output.put_line('Twoje BMI='||bmi||' (grubasie!)');
if bmi<16 then
    dbms_output.put_line('wyglodzenie');
elsif bmi<17 then 
    dbms_output.put_line('wychudzenie');
elsif bmi<18.5 then 
    dbms_output.put_line('niedowaga');
elsif bmi<25 then 
    dbms_output.put_line('masa ok');
elsif bmi<30 then
    dbms_output.put_line('nadwaga');
elsif bmi<35 then
    dbms_output.put_line('I stopieñ przypakowania');
elsif bmi<40 then 
    dbms_output.put_line('II stopieñ przypakowania');
else 
    dbms_output.put_line('III stopieñ przypakowania');
end if;
end;
/


begin
    for x in 1..10 loop
    dbms_output.put_line('siema');
    end loop;
    dbms_output.put_line('koniec');
end;
/




begin
    for x in 1..10 loop
        dbms_output.put_line('siema po raz '||x);
    end loop;
    dbms_output.put_line('koniec');
end;
/

/*Zadanie 6.
*. Wyœwietl 20 kolejnych potêg liczby 2
*/

select power(10,3) from dual;
/

begin
for koza in 1..20 loop
    dbms_output.put_line('2^'||koza||'='||power(2,koza));
end loop;
end;
/


declare
wynik number;
begin
for koza in 1..20 loop
    wynik:=power(2,koza);
    dbms_output.put_line('2^'||koza||'='||wynik);
end loop;
end;

/


declare
wynik number;
x integer;
begin
for koza in 1..20  loop
    x:=koza*2;
    wynik:=power(2,x);
    dbms_output.put_line('2^'||x||'='||wynik);
end loop;
end;
/


declare
wynik number;
x integer;
begin
for koza in 20..1  loop --fuuuu
    x:=koza*2;
    wynik:=power(2,x);
    dbms_output.put_line('2^'||x||'='||wynik);
end loop;
end;
/


declare
wynik number;
begin
for koza in  reverse 1..20  loop --fuuuu
    wynik:=power(2,koza);
    dbms_output.put_line('2^'||koza||'='||wynik);
end loop;
end;
/


begin
for x in  -10..10 loop
    if x<0 then
        dbms_output.put_line(x||' jest mniejsze od 0');
    elsif x=0 then 
        dbms_output.put_line(x||' jest zerem');
    else 
        dbms_output.put_line(x||' jest wiêksze od 0');
    end if;
end loop;
end;

/*
7. Wypisz liczby w zakresie 1-100 obok kazdej piszac czy jest parzysta czy nie
*/

select mod(11,2) from dual;
/

begin
for x in 1..100 loop
    if mod(x,2)=0 then 
        dbms_output.put_line(x||' jest parzysta');
    else
        dbms_output.put_line(x||' jest nieparzysta');
    end if;
end loop;
end;
/

--przerwa obiadowa do 13:24

/*
8. Napisz symulator lokaty. Symulator ma przez zmienne przyjac kwote lokowana, ilosc miesiecy 
na ktora zakladamy lokatê i oprocentowanie w skali roku. Zakladamy comiesieczna kapitalizacje 
odsetek. Dla kazdego miesiaca trwania lokaty wyswietl ktory to miesiac i ile mamy odlozone na 
lokacie. 
*/

declare
konto number:=100000;
ilosc_miesiecy integer:=24;
oprocentowanie number:=0.08;
begin
    for m in 1..ilosc_miesiecy loop
        konto:=round(konto+(konto*oprocentowanie/12),2);
        dbms_output.put_line(m||' '||konto);
    end loop;
end;
/


declare
konto number:=100000;
ilosc_miesiecy integer:=24;
oprocentowanie number:=-0.18;
begin
    for m in 1..ilosc_miesiecy loop
        konto:=round(konto+(konto*oprocentowanie/12),2);
        dbms_output.put_line(m||' '||konto);
    end loop;
end;
/

begin
for x in -10..10 loop
    if x=0 then
        continue;
    end if;
    dbms_output.put_line(x||' '||1/x);
end loop;
end;
/

begin
for x in -10..10 loop
    if x=0 then
        exit;
    end if;
    dbms_output.put_line(x||' '||1/x);
end loop;
end;
/


begin
while(1=1) loop
    null;
end loop;
end;
/


declare
suma integer:=1;
x integer:=1;
begin
while(suma<100) loop
    x:=x+1;
    suma:=suma+x;
    dbms_output.put_line('x='||x||' suma='||suma);
end loop;
end;
/


declare 
cursor k is select * from employees;
begin
for w in k loop
    dbms_output.put_line(w.last_name);
end loop;
end;
/

declare
x integer:=0;
begin
loop
x:=x+1;
dbms_output.put_line(x);
exit when x=10;
end loop;
end;

/


declare
x integer:=0;
begin
loop
x:=x+1;
dbms_output.put_line(x);
if x=10 then exit;
end if;
end loop;
end;
/

/*9.
Korzystajac z petli while lub exit when wyswietlaj kolejne potegi liczby dwa az potega nie wyniesie wiecej niz 10000
*/


declare
wynik number:=0;
np integer:=0;
begin
while(wynik<10000) loop
    np:=np+1;
    wynik:=power(2,np);
    dbms_output.put_line(np||' '||wynik);
end loop;
end;
/


declare
wynik number:=0;
np integer:=0;
begin
while(wynik<10000) loop
    dbms_output.put_line(np||' '||wynik);
    np:=np+1;
    wynik:=power(2,np);    
end loop;
end;
/

declare
wynik number:=0;
np integer:=0;
begin
loop
np:=np+1;
wynik:=power(2,np);
exit when wynik>10000;
dbms_output.put_line(wynik);
end loop;
end;
/


/*10.
Napisz program który bêdzie dodawa³ kolejne wartoœci losowe do sumy (wypisuj¹c ile doda³ i ile wynosi suma)
tak d³ugo a¿ suma nie przekroczy wartoœci podanej przez u¿ytkownika (przez zmienna). Wartoœæ losowa:
execute dbms_output.put_line(round(dbms_random.value(1,1000)));
*/


execute dbms_output.put_line(round(dbms_random.value(1,1000)));
/
declare
wylosowane number;
begin
wylosowane:=round(dbms_random.value(1,1000));
dbms_output.put_line(wylosowane);
end;
/

declare
suma number:=0;
maksimum integer:=1000;
begin
while suma<=maksimum loop
    suma:=suma+round(dbms_random.value(1,10));
    dbms_output.put_line(suma);
end loop;
end;
/

declare
suma number:=0;
maksimum integer:=1000;
begin
loop
    suma:=suma+round(dbms_random.value(1,10));
    exit when suma>maksimum ;
    dbms_output.put_line(suma);
end loop;
end;
/
declare
suma number:=0;
maksimum integer:=1000;
begin
while suma<=maksimum loop
    dbms_output.put_line(suma);
    suma:=suma+round(dbms_random.value(1,10));    
end loop;
end;
/


declare
suma number:=0;
maksimum integer:=1000;
begin
loop
    suma:=suma+round(dbms_random.value(1,10));    
    if suma>maksimum then exit;
    end if;    
    dbms_output.put_line(suma);
end loop;
end;
/

--przerwa do 14:44

begin
execute immediate 'create index ';
end;
/

select * from employees;

begin
update employees set commission_pct=0.5 where department_id=90;
end;
/

declare
prowizja number:=0.5;
departament integer:=90;
begin
update employees set commission_pct=prowizja where department_id=departament;
end;
/

rollback;
/

declare
prowizja number:=0.5;
departament integer:=90;
begin
update employees set commission_pct=prowizja where department_id=departament;
commit;
end;
/

update employees set salary=1000 where department_id=1;

/
declare
prowizja number:=0.5;
departament integer:=90;
begin
update employees set commission_pct=prowizja where department_id=departament;
dbms_output.put_line('zmiana dotyczyla '||sql%rowcount||' wierszy');
commit;
end;
/

declare
prowizja number:=0.5;
departament integer:=900;
begin
update employees set commission_pct=prowizja where department_id=departament;
dbms_output.put_line('zmiana dotyczyla '||sql%rowcount||' wierszy');
if sql%rowcount=0 then 
    dbms_output.put_line('NIE ZMIENIONO ¯ADNEGO WIERSZA!');
end if;
commit;
end;
/



declare
prowizja number:=0.5;
departament integer:=90;
begin
update employees set commission_pct=prowizja where department_id=departament;
commit;
dbms_output.put_line('zmiana dotyczyla '||sql%rowcount||' wierszy');
end;
/

DECLARE
WIERSZ EMPLOYEES%rowtype;
BEGIN
wiersz.last_name:='Klusiewicz';
dbms_output.put_line(wiersz.last_name);
END;
/

/*11.
Napisz program ktory bedzie dawal podwyzki. Kwota podwyzki oraz numer departamentu dla ktorego 
zostanie zastosowana podwyzka maja zostac podane przez uzytkownika (POPRZEZ ZMIENNE).
Operacja ma byæ zatwierdzona transakcyjnie a na konsoli chcemy jeszcze wyswietlic ilu wierszy dotyczyla zmiana.
*/


desc employees;

alter table employees enable row movement;
flashback table employees to timestamp to_timestamp('14-11-2022 14:00:00','dd-mm-yyyy hh24:mi:ss');
/

declare 
ile number:=1000;
nr_departamentu integer:=90;
begin
update employees set salary=salary+ile where department_id=nr_departamentu;
dbms_output.put_line('zmieniono '||sql%rowcount||' wierszy');
commit;
end;
/


create table owoce(
nr_owocu integer primary key,
nazwa_owocu varchar2(4000)
);


insert into owoce values (1,'Banan');
insert into owoce values (2,'Mandarynka');
select * from owoce;

create sequence moja;

select moja.nextval from dual;

create sequence owocowa start with 3 ;
create sequence owocowa start with 3 increment by 1;

insert into owoce values (owocowa.nextval,'XXXXX');
select * from owoce;


create sequence faktury_seq;

create table faktury (
id_faktury integer primary key,
numer_faktury varchar2(4000)
);

create table produkty_na_fakturach (
id_pnf integer primary key,
nazwa varchar2(4000),
id_faktury integer references faktury(id_faktury)
);

begin
insert into faktury values (faktury_seq.nextval,'01/01/2022');
insert into produkty_na_fakturach values (faktury_seq.nextval,'Bulbulator',);
end;

select owocowa.currval from dual;
select owocowa.nextval from dual;
/

declare
id integer;
begin
id:=faktury_seq.nextval;
insert into faktury values (id,'01/01/2022');
insert into produkty_na_fakturach values (faktury_seq.nextval,'Bulbulator',id);
end;

select * from faktury;
select * from produkty_na_fakturach;



declare
id integer;
begin
insert into faktury values (faktury_seq.nextval,'01/01/2022') returning id_faktury into id;
insert into produkty_na_fakturach values (faktury_seq.nextval,'Bulbulator',id);
commit;
end;
/

select * from regions;
/*12.
Napisz program ktory bedzie dodawal wiersze do tabeli regions. Nazwa regionu ma zostac podana przez 
uzytkownika (przez zmienn¹). Numer regionu ma zostac podany z sekwencji a nastepnie po zapisie wiersza wyswietlony na konsoli.
(Chcemy uzyskac region_id pod jakim wyladowal nowo dodany region)
*/

create sequence reg_seq start with 5;

insert into regions values (reg_seq.nextval,'Sosnowiec');

CREATE SEQUENCE regio start with 5 ;
/

select * from user_sequences;



delete from regions where region_id=5;

create sequence rseq start with 5;

declare
nazwa varchar2(4000):='Sosnowiec';
id integer;
begin
insert into regions(region_id,region_name) values (rseq.nextval, nazwa) returning region_id into id;
dbms_output.put_line('Region '||nazwa||' jest pod id='||id);
end;

insert into regions values (5,'xxx');
insert into regions(region_id,region_name) values (5,'xxxx');

/
declare
nazwa varchar2(4000):='&nazwa_regionu';
id integer;
begin
insert into regions(region_id,region_name) values (rseq.nextval, nazwa) returning region_id into id;
dbms_output.put_line('Region '||nazwa||' jest pod id='||id);
end;
/

declare
najwyzszy integer:=4;
begin
delete from regions where region_id>najwyzszy;
end;
/

select * from regions;

/
declare
nazwisko varchar2(4000);
begin
select last_name into nazwisko from employees where employee_id=198;
dbms_output.put_line(nazwisko);
end;
/
declare
nazwisko varchar2(4000);
imie varchar2(4000);
begin
select last_name,first_name into nazwisko,imie from employees where employee_id=198;
dbms_output.put_line(nazwisko);
dbms_output.put_line(imie);
end;
/



declare
nazwisko varchar2(4000);
imie varchar2(4000);
begin
select last_name,first_name into nazwisko,imie from employees; --fuuu
dbms_output.put_line(nazwisko);
dbms_output.put_line(imie);
end;

/

declare
srednia number;
ilosc integer;
begin
select round(avg(salary)),count(*) into srednia,ilosc from employees;
dbms_output.put_line(srednia);
dbms_output.put_line(ilosc);
dbms_output.put_line(srednia||' '||ilosc);
end;
/
select avg(salary),count(*) from employees;
/


/*13.
 Wczytaj do zmiennej a nastêpnie wyœwietl iloœæ osób w departamencie którego numer zostanie podany 
przez uzytkownika
*/
--
--declare
--x integer:=&something;
--begin
--null;
--end;

declare
nr_departamentu integer:=&numer_departamentu;
ilosc integer;
begin
select count(*) into ilosc from employees where department_id=nr_departamentu;
dbms_output.put_line(ilosc);
end;

/


/*14.
Wczytaj do zmiennych i wyœwietl w osobnych liniach imiê, nazwisko i telefon osoby której numer pracownika poda u¿ytkownik.
*/


declare ---fuuuuuuu zle bo trzy odwolania do tabeli
imie varchar2(4000);
nazwisko varchar2(4000);
telefon varchar2(4000);
id integer:=&numer_pracownika;
begin
select first_name into imie from employees where employee_id=id;
select last_name into nazwisko from employees where employee_id=id;
select phone_number into telefon from employees where employee_id=id;
dbms_output.put_line(imie);
dbms_output.put_line(nazwisko);
dbms_output.put_line(telefon);
end;

/


declare
imie varchar2(4000);
nazwisko varchar2(4000);
telefon varchar2(4000);
id integer:=&numer_pracownika;
begin
select first_name,last_name,phone_number into imie,nazwisko,telefon from employees where employee_id=id;
dbms_output.put_line(imie);
dbms_output.put_line(nazwisko);
dbms_output.put_line(telefon);
end;


/
select * from employees;
/
declare
wiersz employees%rowtype;
begin
select * into wiersz from employees where employee_id=1;
exception
when no_data_found then dbms_output.put_line('nie znaleziono wiersza o takim id');
end;
/

declare
wiersz employees%rowtype;
begin
select * into wiersz from employees where employee_id=1;
exception
when others then dbms_output.put_line(sqlerrm);
end;
/


select * from employees where employee_id=100;
select first_name from employees where employee_id=100;

--blob,clob,nclob

/

/*15.
Wczytaj do zmiennej i wyœwietl na konsoli ró¿nicê pomiêdzy najwy¿szymi i najni¿szymi zarobkami 
w departamencie którego nazwê przekaze u¿ytkownik. Program ma byæ niewra¿liwy na wielkoœæ liter 
w nazwie departamentu.
*/

select * from employees;
select * from departments;

select * from departments where lower(department_name)=lower('MARKETING');

SELECT MAX(SALARY)-MIN(SALARY) FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID) WHERE lower(DEPARTMENT_NAME)=lower('It');

select max(salary)-min(salary) from employees where department_id=(select department_id from departments where lower(department_name)=lower('it'));

declare
nazwa_departamentu varchar2(4000):='&nazwa_departamentu';
roznica number;
begin
select max(salary)-min(salary) into roznica from employees where department_id=(select department_id from departments where lower(department_name)=lower(nazwa_departamentu));
dbms_output.put_line('ró¿nica p³ac dla departamentu '||nazwa_departamentu||' wynosi '||roznica);
end;
/

SELECT MAX(SALARY)-MIN(SALARY) FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID) WHERE lower(DEPARTMENT_NAME)=lower('It');

select max(salary)-min(salary) from employees where department_id=(select department_id from departments where lower(department_name)=lower('it'));
/

alter session set tracefile_identifier='to_ja_jestem_plikiem_ktorego_szukasz';
alter session set sql_trace=true;

create table wielka as select * From employees;

begin
for x in 1..14 loop
 insert into wielka select * from wielka;
 commit;
end loop;
end;

declare
cursor k is 
select * from wielka order by last_name;
begin
for w in k loop
null;
end loop;
end;
/

select 504069/17595097 from dual;

--przerwa do 10:29
/

declare
wiersz departments%rowtype;
begin
wiersz.department_name:='Coœtam';
dbms_output.put_line(wiersz.department_name);
end;
/

select * from departments;
/

declare
wiersz departments%rowtype;
begin
select * into wiersz from departments where department_id=90;
dbms_output.put_line(wiersz.department_name);
end;
/


declare
wiersz departments%rowtype;
begin
select * into wiersz from departments where department_id=90;
dbms_output.put_line(upper(wiersz.department_name));
end;
/



/*16.
Wczytaj do zmiennej caly wiersz pracownika ktorego numer poda uzytkownik. Nastepnie wyswietl
na konsoli imie, nazwisko, wynagrodzenie i datê zatrudnienia pracownika w formacie dd-mm-yyyy z wiersza.
*/


select * from employees;
select to_char(sysdate,'dd-mm-yyyy'),sysdate from dual;

alter SESSION  set NLS_DATE_FORMAT = 'dd-mm-yyyy';
/
declare
wiersz employees%rowtype;
nr_pracownika integer:=&numer_pracownika;
begin
select * into wiersz from employees where employee_id=nr_pracownika;
dbms_output.put_line(wiersz.first_name);
dbms_output.put_line(wiersz.last_name);
dbms_output.put_line(wiersz.salary);
dbms_output.put_line(to_char(wiersz.hire_date,'dd-mm-yyyy'));
end;

/

execute dbms_output.put_line('coœ'||chr(13)||'coœ jeszcze');
/


declare
type rekordowy is record(
 nazwisko varchar2(4000),
 departament varchar2(4000)
);
rek rekordowy;
begin
select last_name,department_name into rek from employees join departments using(department_id) where employee_id=100;
dbms_output.put_line(rek.nazwisko);
dbms_output.put_line(rek.departament);
end;
/



declare
type rekordowy is record(
 nazwisko employees.last_name%type,
 departament varchar2(4000)
);
rek rekordowy;
begin
select last_name,department_name into rek from employees join departments using(department_id) where employee_id=100;
dbms_output.put_line(rek.nazwisko);
dbms_output.put_line(rek.departament);
end;
/

desc employees;
/

/*17.
Wczytaj do zmiennej typu rekordowego zaokraglona srednia, minimum i maksimum zarobkow
w departamencie ktorego numer zostanie podany przez uzytkownika. Wczytane dane wyswietl na konsoli
*/

declare
type rekordowy is record(
srednia number,
minimum number,
maksimum number
);
rek rekordowy;
begin
select round(avg(salary)),min(salary),max(salary) into rek from employees where department_id=&numer_departamentu;
dbms_output.put_line('srednia='||rek.srednia);
dbms_output.put_line('minimum='||rek.minimum);
dbms_output.put_line('maksimum='||rek.maksimum);
end;
/

declare
cursor k is select * from employees;
begin
for w in k loop
    dbms_output.put_line(w.first_name||' '||w.last_name);
end loop;
end;
/


declare
cursor k is select first_name,last_name from employees;
begin
for w in k loop
    dbms_output.put_line(w.first_name||' '||w.last_name);
end loop;
end;
/

select * from employees;
drop index emp_name_ix;
select firsT_name,last_name from employees;
create index omg_wtf on employees(last_name,first_name);

select * from employees where department_id=90;

create index abc on employees(department_id);

select department_id,rowid from employees order by 1;
select * from employees where rowid in  ('AAAR6YAAEAAALBeAAE','AAAR6YAAEAAALBeAAD');
/



declare
cursor k is 
select first_name,last_name,job_title from employees join jobs using(job_id);
begin
for w in k loop
    dbms_output.put_line(w.first_name||' '||w.last_name||' '||w.job_title);
end loop;
end;
/


begin
 for w in (select last_name from employees) loop
    dbms_output.put_line(w.last_name);
 end loop;
end;
/


declare
cursor k is 
select first_name,last_name,job_title from employees join jobs using(job_id);
begin
for w in k loop
    dbms_output.put_line(w.first_name||' '||w.last_name||' '||w.job_title);
end loop;
end;
/

declare
cursor k is 
select first_name,last_name,job_title from employees join jobs using(job_id);
w k%rowtype;
begin
open k;
loop
    fetch k into w;
    exit when k%notfound;
    dbms_output.put_line(w.first_name||' '||w.last_name||' '||w.job_title);
end loop;    
close k;
end;
/

declare
cursor k is select * from employees;
type tablica is table of k%rowtype index by binary_integer;
tab tablica;
begin
open k;
fetch k bulk collect into tab;
close k;
dbms_output.put_line(tab.count);
end;
/


/*18.
Korzystajac z kursora wyœwietl na konsoli nazwiska, daty zatrudnienia w formacie dd-mm-yyyy
 i nazwy departamentów wszystkich pracowników
*/

select first_name,last_name,job_title,job_id from employees join jobs using(job_id);
select first_name,last_name,job_title,e.job_id from employees e join jobs j on e.job_id=j.job_id;


create table employees2 as select * from employees;
create table jobs2 as select * from jobs;

select first_name,last_name,job_title from employees2 join jobs2 using(job_id);
create index pierwszy on employees2(job_id,first_name,last_name);
create index drugi on jobs2(job_id,job_title);


select * from wielka;
select count(*) from wielka;
update wielka set salary=salary+1;

/
declare
cursor k is 
select last_Name,to_char(hire_date,'dd-mm-yyyy') data_zatr,department_name  from employees join departments using(department_id);
begin
for w in k loop
    dbms_output.put_line(w.last_name||' '||w.data_zatr||' '||w.department_name);
end loop;
end;
/


declare
cursor k is 
select last_Name,hire_date,department_name  from employees join departments using(department_id);
begin
for w in k loop
    dbms_output.put_line(w.last_name||' '||to_char(w.hire_date,'dd-mm-yyyy')||' '||w.department_name);
end loop;
end;
/


--przerwa do 11:58


/*19.
Korzystaj¹c z kursora wyœwietl nazwy departamentów i liczbê pracowników w nich. Wynik powinien byæ posortowany
malej¹co po liczbie pracowników.
*/


declare
cursor k is 
select department_name, count(*) ilosc from employees join departments using(department_id) group by department_name 
order by 2 desc;
begin
for w in k loop
    dbms_output.put_line(w.department_name||' '||w.ilosc);
end loop;
end;
/


select count(*) from employees where department_id=90;
select last_name,first_name from employees where department_id=90;
create index rotfl on employees(department_id,last_name,first_name);

/
declare
cursor k is select last_name,first_name from employees where department_id=90;
w k%rowtype;
begin
open k;
fetch k into w;
dbms_output.put_line(w.first_name);
fetch k into w;
dbms_output.put_line(w.first_name);
close k;
end;
/



/*20.
 Napisz program który odbierze od u¿ytkownika  numer departamentu,
 wyœwietli na konsoli liczbê pracowników w tym departamencie, a poni¿ej wyœwietli 
listê imion i nazwisk osób z tego departamentu.
*/

declare
ilosc integer;
nd integer:=&numer_departamentu;
cursor k is
select last_name,first_name from employees where department_id=nd;
begin
select count(*) into ilosc from employees where department_id=nd;
dbms_output.put_line('iloœæ pracowników w departamencie '||nd||' wynosi '||ilosc);
for w in k loop
    dbms_output.put_line(w.first_name||' '||w.last_name);
end loop;
end;
/


declare
nd integer:=90;
cursor k is select * from employees where department_id=nd;
begin
for w in k loop
    dbms_output.put_line(w.last_name);
end loop;
end;
/


declare
cursor k(nd integer) is select * from employees where department_id=nd;
begin
for w in k(90) loop
    dbms_output.put_line(w.last_name);
end loop;
end;
/

begin
    for y in 1..10 loop
        for x in 1..10 loop
            dbms_output.put_line('y='||y||' x='||x);
        end loop;
    end loop;
end;
/

/*21.
Wyœwietl nazwy wszystkich departamentów a po ka¿dej nazwie departamentu listê
imion i nazwisk osób w nich zatrudnionych. PodpowiedŸ: powinny byæ dwa kursory z czego jeden sparametryzowany.
*/

declare
cursor kursor_departamenty is select department_id,department_name from departments
where department_id in (select department_id from employees);
cursor kursor_pracownicy(did integer) is select last_name,first_name from employees where department_id=did;
begin
for d in kursor_departamenty loop
    dbms_output.put_line('###### '||d.department_name);
    for p in kursor_pracownicy(d.department_id) loop
        dbms_output.put_line(p.firsT_name||' '||p.last_Name);            
    end loop;
end loop;
end;
/




declare
did integer;
cursor kursor_departamenty is select department_id,department_name from departments
where department_id in (select department_id from employees);
cursor kursor_pracownicy is select last_name,first_name from employees where department_id=did;
begin
for d in kursor_departamenty loop
    dbms_output.put_line('###### '||d.department_name);
    did:=d.department_id;
    for p in kursor_pracownicy loop
        dbms_output.put_line(p.firsT_name||' '||p.last_Name);            
    end loop;
end loop;
end;
/

declare
cursor kursor_departamenty is select department_id,department_name from departments
where department_id in (select department_id from employees);
begin
for d in kursor_departamenty loop
    dbms_output.put_line('###### '||d.department_name);    
    for p in (select last_name,first_name from employees where department_id=d.DEPARTMENT_ID) loop
        dbms_output.put_line(p.firsT_name||' '||p.last_Name);            
    end loop;
end loop;
end;
/

--PRZERWA OBIADOWA DO 13:36

/*22.
Wyœwietl wynik dzielenia 1 przez kolejne liczby z zakresu -10 do 10. 
*/

begin
for x in -10..10 loop
    dbms_output.put_line(x||' '||1/x);
end loop;
end;

/


begin
dbms_output.put_line(1/0);
exception
when others then dbms_output.put_line('wyj¹tek: '||sqlerrm||' '||sqlcode);
end;

/


begin
dbms_output.put_line(1/0);
exception
when invalid_cursor then dbms_output.put_line('To siê nie ma prawa zdarzyc'); 
when zero_divide then dbms_output.put_line('dzielenie przez zero!'); 
when others then dbms_output.put_line('wyj¹tek: '||sqlerrm||' '||sqlcode);
end;

/



begin
dbms_output.put_line(1/0);
dbms_output.put_line('coœtam dalej');
exception
when invalid_cursor then dbms_output.put_line('To siê nie ma prawa zdarzyc'); 
when zero_divide then dbms_output.put_line('dzielenie przez zero!'); 
when others then dbms_output.put_line('wyj¹tek: '||sqlerrm||' '||sqlcode);
end;
/


begin
    begin
        dbms_output.put_line(1/0);
    exception
        when invalid_cursor then dbms_output.put_line('To siê nie ma prawa zdarzyc'); 
        when zero_divide then dbms_output.put_line('dzielenie przez zero!'); 
        when others then dbms_output.put_line('wyj¹tek: '||sqlerrm||' '||sqlcode);        
    end;
dbms_output.put_line('coœtam dalej');
end;

/*23.
Wyœwietl wynik dzielenia 1 przez kolejne liczby w zakresue -10 do 10, tak by 
w przypadku pojawienia siê wyjatku nie przerywac dzialania pêtli
a jedynie wyswietlic przy jakiej wartosci i jaki wyjatek sie pojawil.
*/
/
begin
for x in -10..10 loop
dbms_output.put_line(x||' '||1/x);
end loop;
exception ---fuuuuu, nie w tym miejscu!
when zero_divide then dbms_output.put_line('nie dziel przez zero');
end;
/


begin
for x in -10..10 loop
    begin
        dbms_output.put_line(x||' '||1/x);
    exception --- om nom nom
        when zero_divide then dbms_output.put_line('nie dziel przez zero na '||x);
    end;
end loop;
end;
/

/*24.
Wczytaj do zmiennych i wyœwietl dane (imie,nazwisko,telefon,email) osoby której numer zostanie podany przez u¿ytkownika.
Obs³u¿ wyj¹tek który pojawia siê gdy podasz id nieistniej¹cego pracownika. Obs³uga wyj¹tku powinna sprowadzaæ
siê do wyswietlenia stosownego komunikatu na konsoli.
*/

--https://jsystems.pl/temp/adminka.pdf
--https://jsystems.pl/temp/tuning.pdf
--https://blog.jsystems.pl/show_post/Bezp%C5%82atny_kurs_Python_od_podstaw/

--no_data_found

/
declare
wiersz employees%rowtype;
np integer:=&numer_pracownika;
begin
select * into wiersz from employees where employee_Id=np;
dbms_output.put_line(wiersz.first_name);
dbms_output.put_line(wiersz.last_name);
dbms_output.put_line(wiersz.phone_number);
dbms_output.put_line(wiersz.email);
exception 
when NO_DATA_FOUND then dbms_output.put_line('nie ma pracownika o numerze '||np);
end;
/

begin
raise_application_error(-20001,'kij ci w oko!');
end;
/

begin
raise no_data_found;
end;
/

declare
wyjatek exception;
pragma exception_init(wyjatek,-20001);
begin
raise_application_error(-20001,'kij ci w oko!');
exception
when wyjatek then dbms_output.put_line('abc...');
end;
/

--przerwa do 14:50


create or replace procedure odpal_mnie is 
begin
dbms_output.put_line('siema, to ja!');
end;

--Maciej Aniserowicz devstyle.pl - kurs git 


execute odpal_mnie;

begin
odpal_mnie;
end;
/


create or replace procedure odpal_mnie is 
zmienna integer;
x number;
y date;
begin
dbms_output.put_line('siema, to ja!');
end;
/

create or replace procedure jedz_owoc(nazwa varchar2) is 
begin
 dbms_output.put_line('om nom nom '||nazwa);
end;
/

execute jedz_owoc('banan');

/


create or replace procedure jedz_owoc(nazwa varchar2) is 
begin
 dbms_output.put_line('om nom nom '||nazwa);
end;
/


/*
25.
Napisz procedurê która przyjmie  przez argumenty imiê i nazwisko i wydrukuje na konsoli 
powitanie typu "Witaj TwojeImie TwojeNazwisko".
*/

create or replace procedure witacz(imie varchar2,nazwisko varchar2) is
begin
    dbms_output.put_line('Witaj '||imie||' '||nazwisko||'!');
end;
/

execute witacz('Andrzej','Klusiewicz');

/*26.
Napisz procedurê która przyjmie wzrost i masê a wyœwietli na konsoli obiczone i zaokraglone
do 2 miejsc po przecinku bmi. Obs³u¿ ewentualny wyj¹tek który mo¿e siê pojawiæ gdy podasz wzrost zero.
*/

create or replace procedure da_fuq(x number) is
begin
null;
end;
/
execute da_fuq(1.7);

DECLARE 
COS NUMBER:=1.7;
begin
da_fuq(COS);
end;
/

create or replace procedure bmi_proc(wzrost number,masa number) is 
bmi number;
begin
    bmi:=round(masa/power(wzrost,2),2);
    dbms_output.put_line('bmi='||bmi);
end;

declare
w number:=1.76;
m number:=72;
begin
bmi_proc(w,m);
end;
/


create or replace procedure bmi_proc(wzrost number,masa number) is 
bmi number;
begin
    bmi:=round(masa/power(wzrost,2),2);
    dbms_output.put_line('bmi='||bmi);
exception
when zero_divide then dbms_output.put_line('poda³eœ zerowy wzrost');
end;
/
--
declare
w number:=0;
m number:=72;
begin
bmi_proc(w,m);
end;
/

/*27.
Napisz procedurê która wypisze imiona i nazwiska osób z dzialu ktorego numer zostanie
podany przy wywolaniu jako argument procedury.
*/


create or replace procedure lista_osob(nd integer) is 
cursor k is select first_name,last_name from employees where department_id=nd;
begin
for w in k loop
    dbms_output.put_line(w.first_name||' '||w.last_name);
end loop;
end;
/

execute lista_osob(90);
/

create or replace procedure lista_osob(nd integer) is 
cursor k is select first_name,last_name from employees where department_id=nd;
ilosc integer;
begin
select count(*) into ilosc from employees where department_id=nd;
if ilosc=0 then 
    raise_application_error(-20001,'nie ma osób w tym dziale');
end if;
for w in k loop
    dbms_output.put_line(w.first_name||' '||w.last_name);
end loop;
end;
/

execute lista_osob(90);
execute lista_osob(0);

/

create or replace procedure lista_osob(nd integer) is 
cursor k is select first_name,last_name from employees where department_id=nd;
ilosc integer;
begin
for w in k loop
    dbms_output.put_line(k%rowcount||' '||w.first_name||' '||w.last_name);
end loop;
end;
/


create or replace procedure lista_osob(nd integer) is 
cursor k is select first_name,last_name from employees where department_id=nd;
ilosc integer:=0;
begin
for w in k loop
    ilosc:=k%rowcount;
    dbms_output.put_line(k%rowcount||' '||w.first_name||' '||w.last_name);
end loop;
if ilosc=0 then
    dbms_output.put_line('nie ma osób w tym dziale');
end if;
end;
/

execute lista_osob(90);
execute lista_osob(9);


create or replace procedure lista_osob(nd integer) is 
cursor k is select first_name,last_name from employees where department_id=nd;
ilosc integer:=0;
ok integer:=0;
begin
for w in k loop
    ok:=1;
    dbms_output.put_line(k%rowcount||' '||w.first_name||' '||w.last_name);
end loop;
if ilosc=0 then
    dbms_output.put_line('nie ma osób w tym dziale');
end if;
end;


/

/*28.
Napisz procedurê która przyjmie przez argumenty numer dzialu i podwyzkê. Procedura
ma dac podwy¿kê osobom z dzialu ktorego numer zostanie podany przy wywolaniu (podobnie jak podwyzka).
Jeœli podwy¿ka nie zostanie zastosowana na ¿adnym wierszu, chcemy wywo³aæ wyj¹tek z odpowiednim komunikatem.
Zmiany wprowadzone przez tê procedurê maja byc utrwalone transakcyjnie.
*/

update employees set salary=salary+1000 where department_id=1;

execute podwyzka(90,1000);

create or replace procedure podwyzka(nd integer,ile number) is
begin
update employees set salary=salary+ile where department_id=nd;
if sql%rowcount=0 then
    raise_application_error(-20001,'Nikt nie dosta³ podwy¿ki');
end if;
commit;
end;

execute podwyzka(0,1000);
/


/*
29. Napisz procedurê która przyjmie numer departamentu a wyœwietli na konsoli 
nazwê tego departamentu, srednia zarobkow w nim zaokraglona do 2 miejsc po 
przecinku, ilosc pracownikow w nich. Wszystko w osobnych liniach ze stosownym opisem
np. Nazwa departamentu=IT
*/

select department_name from departments where department_id=90;
select avg(salary) from employees where department_id=90;
select count(*) from employees where department_id=90;



select department_name from departments where department_id=90;
select count(*),avg(salary) from employees where department_id=90;

select department_name,round(avg(salary),2), count(*) from employees join departments
using(department_id)
where department_id=90
group by department_name;
/
create or replace procedure statystyki(did integer)is
nazwa departments.department_name%type;
srednia number;
liczba integer;
begin
select department_name,round(avg(salary),2), count(*) 
into nazwa,srednia,liczba
from employees join departments
using(department_id)
where department_id=did
group by department_name;
dbms_output.put_line('nazwa departamentu='||nazwa);
dbms_output.put_line('œrednia zarobków='||srednia);
dbms_output.put_line('liczba pracowników='||liczba);
exception 
when no_data_found then dbms_output.put_line('nie ma takiego departamentu');
end;
/
execute statystyki(90);
execute statystyki(0);
/


begin
for x in 1..10 loop
sys.dbms_session.sleep(1);
dbms_output.put_line('x='||x);
end loop;
end;
/

/

--przerwa do 10:47

/*30.
Napisz procedurê która bêdzie przyjmowa³a nazwê pakietu, nazwê procedury lub funkcji, informacjê o zdarzeniu przez argument i zapisywa³a do 
osobnej tabelki wiersz zawierajacy klucz glowny, timestamp zdarzenia, u¿ytkownika wywo³uj¹cego procedurê oraz
informacje przekazane przez argumenty
log('jakas informacja')
*/

create sequence log_seq;

create table logs(
log_id integer primary key,
log_timestamp timestamp not null,
logged_user varchar2(30) not null,
package_name varchar2(4000) not null,
function_name varchar2(4000) not null,
info clob
);

select user from dual;
select systimestamp from dual;

begin
zalogowany:=user;
end;

execute log('nazwa_pakietu','nazwa_procedury/funkcji','operacja przebiegla pomyslnie');

insert into tabela values (nazwa_sekwencji.nextval, );

/
--__name__

create or replace procedure wow is 
begin
dbms_output.put_line($$PLSQL_UNIT);
end;
/
execute wow;

create or replace package omg is
procedure wow;
end;
/
create or replace package body omg is 
procedure wow is 
begin
dbms_output.put_line($$PLSQL_UNIT);
end;
end;
/
execute omg.wow;

execute loguj('pakiet_etl','oczyszczanie_danych','');


/*30.
Napisz procedurê która bêdzie przyjmowa³a nazwê pakietu, nazwê procedury lub funkcji, informacjê o zdarzeniu przez argument i zapisywa³a do 
osobnej tabelki wiersz zawierajacy klucz glowny, timestamp zdarzenia, u¿ytkownika wywo³uj¹cego procedurê oraz
informacje przekazane przez argumenty
log('jakas informacja')
*/

create sequence log_seq;

create table logs(
log_id integer primary key,
log_timestamp timestamp not null,
logged_user varchar2(30) not null,
package_name varchar2(4000) not null,
function_name varchar2(4000) not null,
info clob
);

create or replace procedure loguj(nazwa_pakietu varchar2,nazwa_procedury varchar2,info_about clob) is
begin
insert into logs(log_id,log_timestamp,logged_user,package_name,function_name,info) 
values (log_seq.nextval,systimestamp,user,nazwa_pakietu,nazwa_procedury,info_about);
end;
/

execute loguj('ETL','CLEAN_DATA','wszystko siê uda³o');
select * from logs;

a;
loguj(.....)
b;
loguj(.....)
c;
loguj(.....)
d;
loguj(.....)
/


create or replace procedure loguj(nazwa_pakietu varchar2,nazwa_procedury varchar2,info_about clob) is
pragma autonomous_transaction;
begin
insert into logs(log_id,log_timestamp,logged_user,package_name,function_name,info) 
values (log_seq.nextval,systimestamp,user,nazwa_pakietu,nazwa_procedury,info_about);
commit;
end;
/

select * from employees;
update employees set salary=1000;

execute loguj('XI','JINGPING','wprowadzono komunizm');
select * from logs;
rollback;


begin
for x in 1..10 loop
sys.dbms_session.sleep(1);
--dbms_output.put_line('x='||x);
loguj('XI','JINGPING','x='||x);
end loop;
end;
/

--przerwa do 12:03

/

select salary from employees;

create or replace function brutto(netto number) return number is
begin
return round(netto*1.23,2);
end;
/

create or replace function brutto(netto number) return number is
wynik number;
begin
wynik:=round(netto*1.23,2);
return wynik;
null;
end;
/

select salary,brutto(salary) from employees;



/
create or replace function wiele_returnow(x integer) return varchar2 is
begin
if x=1 then
    return 'jeden';
elsif x=2 then 
    return 'dwa';
else 
    return 'poza zakresem';
end if;
end;
/
select wiele_returnow(1) from dual;
select wiele_returnow(3) from dual;
/

select last_name,months_between(sysdate, hire_date) from employees;

/

create or replace function years_between(d1 date,d2 date) return number is 
begin
return months_between(d1,d2)/12;
end;
/

select last_name,months_between(sysdate, hire_date),years_between(sysdate,hire_date) from employees;

grant execute on brutto to hr;

select hr.brutto(1) from dual;

begin
procedura;
end;

execute procedura;

execute brutto(1); ---fuuu

select brutto(1) from dual;
/
declare
wynik number;
begin
wynik:=brutto(1);
dbms_output.put_line(wynik);
end;
/

begin
dbms_output.put_line(brutto(1));
end;
/

/*31.
napisz funkcjê która odbierze przez argumenty wzrost i masê a zwróci obliczone bmi.
*/

create or replace function funkcja return integer is 
begin
dbms_output.put_line('dupa!');
return 1;
end;
/

select funkcja from dual;

execute dbms_output.put_line('ok');

create or replace function bmi(w number,m number) return number is 
begin
    return round(m/power(w,2),2);
end;

select bmi(1.76,80) from dual;
select bmi(0,80) from dual;

/


create or replace function bmi(w number,m number) return number is 
begin
    return round(m/power(w,2),2);
exception 
when zero_divide then dbms_output.put_line('wzrost jest równy zero');
return -1;
end;
/
select bmi(0,80) from dual;

execute dbms_output.put_line('ok');


/*32.
napisz funkcjê która przyjmie datê a zwróci z niej tylko rok. Przetestuj jej dzialanie na kolumnie hire_date
*/

select to_char(sysdate,'yyyy') from dual;

select last_name,hire_date,rok(hire_date) from employees;


create or replace function rok(d date) return number is
begin
return to_char(d,'yyyy');
end;
/

select last_name,hire_date,rok(hire_date) from employees;


select rok(to_date('16-11-2022','dd-mm-yyyy')) from dual;

/*33.
Napisz funkcjê która zwróci ilosc pracownikow w departamencie ktorego numer
zostanie podany przez argument tej funkcji.
*/

create or replace procedure print(x varchar2) is 
begin
dbms_output.put_line(x);
end;
/

execute print('dupa');
/

create or replace function ile_pracownikow(did integer) return integer is 
x integer;
begin
    select count(*) into x from employees where department_id=did;
    return x;
end;

select ile_pracownikow(90) from dual;
select ile_pracownikow(0) from dual;
/



create or replace function ile_pracownikow(did integer) return integer is 
x integer;
y integer;
begin
    select count(*) into y from departments where department_id=did;
    if y=0 then
        raise_application_error(-20001,'nie ma takiego dzia³u');
    end if;
    select count(*) into x from employees where department_id=did;
    return x;
end;
/

select ile_pracownikow(0) from dual;
/

/*34.
Napisz funkcjê która zwróci jeden wiersz pracownika którego numer zostanie podany 
przez argument funkcji. Odbierz ten wiersz w bloku anonimowym i wyœwietl z niego na konsoli imiê, nazwisko i numer telefonu.
Ogarnij tez sytuacje gdy ktos poda id nieistniejacego pracownika.
*/

create or replace function pracownik(eid integer) return employees%rowtype is 
wiersz employees%rowtype;
begin
select * into wiersz from employees where employee_id=eid;
return wiersz;
exception 
when no_data_found then return wiersz;
end;
/
declare
wiersz employees%rowtype;
begin
wiersz:=pracownik(100);
print('########################');
print(wiersz.first_name);
print(wiersz.last_name);
print(wiersz.phone_number);
print('########################');
end;
/


--przerwa obiadowa do 14:00


--a-->b-->c
--
--extract;
--transform;
--load;

--odpal_ten_stuff;


create or replace package pakiecik is 
procedure witacz;
procedure witacz(imie varchar2);
function dajkoze return varchar2;
end;
/

create or replace package body pakiecik is 
procedure witacz is 
begin
    dbms_output.put_line('siema!');
end;

procedure witacz(imie varchar2) is 
begin
    dbms_output.put_line('Witaj '||imie||'!');
end;


function dajkoze return varchar2 is 
begin
return 'koza';
end;

end;
/

execute pakiecik.witacz;
execute pakiecik.witacz('Andrzej');
select pakiecik.dajkoze from dual;

select round(10/3),round(10/3,2) from dual;

/*35.
Stwórz pakiet który bêdzie posiadal 2 funkcje. Jedna przyjmuje wzrost i mase a zwraca bmi,
a druga przyjmuje bmi a zwraca opis dla bmi (niedowaga, nadwaga etc). Przetestuj dzialanie funkcji.
*/

create or replace package cwiczenie35 is
function bmi(w number,m number) return number;
function opis_bmi(b number) return varchar2;
end;
/

create or replace package body cwiczenie35 is 
function bmi(w number,m number) return number is
begin
    return round(m/power(w,2),2);
end;

function opis_bmi(b number) return varchar2 is
begin
if b<16 then
    return 'wyglodzenie';
elsif b<17 then 
    return 'wychudzenie';
elsif b<18.5 then 
    return 'niedowaga';
elsif b<25 then 
    return 'masa ok';
elsif b<30 then
    return 'nadwaga';
elsif b<35 then
    return 'I stopieñ przypakowania';
elsif b<40 then 
    return 'II stopieñ przypakowania';
else 
    return 'III stopieñ przypakowania';
end if;
end;
end;
/
select cwiczenie35.opis_bmi( cwiczenie35.bmi(1.76,80)  ) from dual;
select cwiczenie35.bmi(1.76,80) from dual;
select cwiczenie35.opis_bmi(26) from dual;

/*36.
Stwórz pakiet który bêdzie posiada³ dwie przeci¹¿one procedury o nazwie statystyka. Jedna z procedur
ma nie przyjmowaæ ¿adnego argumentu, druga ma przyjmowaæ argument bêd¹cy liczb¹ ca³kowit¹. Pierwsza ma wydrukowaæ
na konsoli œrednie, maksymalne i minimalne zarobki w ca³ej firmie, druga te same dane ale dla dzia³u którego
numer zostanie podany przez argument tej procedury.
*/
