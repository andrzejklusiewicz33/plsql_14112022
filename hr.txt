select * from employees;
--przerwa do 10:43
--blok anonimowy
--procedura
--funkcja
--trigger / wyzwalacz
--pakiet 
/
begin
null;
end;
/
begin
dbms_output.put_line('hello world!');
end;
/
set serveroutput on;
/

declare
owoc varchar2(4000);
x integer;
y number;
z date;
begin
dbms_output.put_line('hello world!');
end;
/


declare
owoc varchar2(4000):='banan';
x integer:=200;
y number;
z date;
begin
x:=100;
dbms_output.put_line('hello world! owoc='||owoc||' x='||x);
end;
/

/*1.
Stwórz blok anonimowy który przyjmie poprzez zmienne twoje imie oraz nazwisko, 
a nastepnie wyswietli komunikat typu witaj twoje_imie twoje_nazwisko!
*/

--first_name
--firstName


declare
first_name varchar2(4000):='Andrzej';
last_name varchar2(4000):='Klusiewicz';
begin
dbms_output.put_line('Witaj '||first_name||' '||last_name||'!');
end;
/


declare
first_name varchar2(4000);
last_name varchar2(4000);
begin
firsT_name:='Andrzej';
last_name:='Klusiewicz';
dbms_output.put_line('Witaj '||first_name||' '||last_name||'!');
end;
/

declare
x integer:=10;
y integer:=3;
begin
dbms_output.put_line(x/y);
end;
/


declare
x integer:=10;
y integer:=3;
wynik number:=x/y;
begin
dbms_output.put_line(wynik);
end;
/


declare
x integer:=10;
y integer:=3;
wynik number;
begin
wynik:=round(x/y,2);
dbms_output.put_line(wynik);
end;
/


declare
x integer:=10;
y integer:=6;
wynik number;
begin
wynik:=round(x/y,2);
dbms_output.put_line(wynik);
end;
/


declare
x integer:=10;
y integer:=6;
wynik number;
begin
wynik:=trunc(x/y,2);
dbms_output.put_line(wynik);
end;
/

/*2.
napisz program który przyjmie przez zmienne wzrost w metrach i masê w kilogramach a nastepnie 
wyliczy i wypisze zaokraglone do 2 miejsc po przecinku bmi wg. wzoru masa/(wzrost*wzrost)
*/

select 72/power(1.76,2) from dual;
/

declare
wzrost number:=1.76;
masa number:=72;
bmi number:=round(masa/power(wzrost,2),2);
begin
dbms_output.put_line('Twoje BMI='||bmi||' (grubasie!)');
end;

/

declare
wzrost number:=1.76;
masa number:=72;
bmi number;
begin
bmi:=round(masa/power(wzrost,2),2);
dbms_output.put_line('Twoje BMI='||bmi||' (grubasie!)');
end;

/



declare
wzrost number:=0;
masa number:=72;
bmi number;
begin
bmi:=round(masa/power(wzrost,2),2);
dbms_output.put_line('Twoje BMI='||bmi||' (grubasie!)');
exception 
when zero_divide then dbms_output.put_line('wzrost jest równy zero!');
end;
/

declare
wzrost number:=0;
masa number:=72;
bmi number:=round(masa/power(wzrost,2),2);
begin
dbms_output.put_line('Twoje BMI='||bmi||' (grubasie!)');
exception 
when zero_divide then dbms_output.put_line('wzrost jest równy zero!');
end;
/

create or replace procedure hello is 
begin
dbms_output.put_line(1/0);
end;
/

execute hello;
/



declare
wzrost number:=1.76;
masa number:=72;
bmi integer:=round(masa/power(wzrost,2),2); -----fuuuuuu - zaokr¹glanie do calosci nastepuje!
begin
dbms_output.put_line('Twoje BMI='||bmi||' (grubasie!)');
exception 
when zero_divide then dbms_output.put_line('wzrost jest równy zero!');
end;
/

declare
x integer:=1;
begin
if x=1 then
    dbms_output.put_line('jeden!');
    dbms_output.put_line('jeden!');
    dbms_output.put_line('jeden!');
end if;
dbms_output.put_line('koniec');
end;
/


declare
x integer:=2;
begin
if x=1 then
    dbms_output.put_line('jeden!');    
else 
    dbms_output.put_line('nie jeden!');
end if;
dbms_output.put_line('koniec');
end;
/



declare
x integer:=1;
begin
if x=1 then
    dbms_output.put_line('jeden!');    
    dbms_output.put_line('jeden!');    
    dbms_output.put_line('jeden!');    
elsif x=2 then
    dbms_output.put_line('dwa!');
elsif x=3 then 
    dbms_output.put_line('trzy!');
else 
    dbms_output.put_line('albo mniej niz jeden, albo wiecej niz trzy');
end if;
dbms_output.put_line('koniec');
end;
/


declare --fuuuuuu
x integer:=2;
begin
if x=1 then
    dbms_output.put_line('jeden!');    
end if;    
if x=2 then
    dbms_output.put_line('dwa!');
end if;
if x=3 then 
    dbms_output.put_line('trzy!');
end if;
dbms_output.put_line('koniec');
end;
/

/*3.
*. Napisz blok anonimowy który przyjmie przez zmienn¹ wartoœæ liczbow¹ i wypisze czy wartoœæ ta jest mniejsza, równa czy wiêksza ni¿ 0.
*/

declare
x integer:=-10;
begin
if x>0 then 
    dbms_output.put_line('liczba dodatnia');
elsif x=0 then 
    dbms_output.put_line('zero!');
elsif x<0 then 
    dbms_output.put_line('liczba ujemna');
end if;    
end;
/
--if x>0{
--    
--}
/

declare
x integer:=-10;
begin
if x>0 then 
    dbms_output.put_line('liczba dodatnia');
elsif x=0 then 
    dbms_output.put_line('zero!');
else  
    dbms_output.put_line('liczba ujemna');
end if;    
end;
/

--przerwa do 12:00


/*
5. Napisz program który przyjmie od uzytkownika (przez zmienne) jego wzrost i masê, obliczy bmi i wyswietli stosowny opis wg. Wikipedii
*/

declare
wzrost number:=1.76;
masa number:=72;
bmi number;
begin
bmi:=round(masa/power(wzrost,2),2);
dbms_output.put_line('Twoje BMI='||bmi||' (grubasie!)');
end;
/
--https://pl.wikipedia.org/wiki/Wska%C5%BAnik_masy_cia%C5%82a


declare
wzrost number:=1.76;
masa number:=72;
bmi number;
begin
bmi:=round(masa/power(wzrost,2),2);
dbms_output.put_line('Twoje BMI='||bmi||' (grubasie!)');
if bmi<16 then
    dbms_output.put_line('wyglodzenie');
elsif bmi>=16 and bmi<17 then ---fuuuuuu
    dbms_output.put_line('wychudzenie');
end if;
end;
/



declare
wzrost number:=1.76;
masa number:=93;
bmi number;
begin
bmi:=round(masa/power(wzrost,2),2);
dbms_output.put_line('Twoje BMI='||bmi||' (grubasie!)');
if bmi<16 then
    dbms_output.put_line('wyglodzenie');
elsif bmi<17 then 
    dbms_output.put_line('wychudzenie');
elsif bmi<18.5 then 
    dbms_output.put_line('niedowaga');
elsif bmi<25 then 
    dbms_output.put_line('masa ok');
elsif bmi<30 then
    dbms_output.put_line('nadwaga');
elsif bmi<35 then
    dbms_output.put_line('I stopieñ przypakowania');
elsif bmi<40 then 
    dbms_output.put_line('II stopieñ przypakowania');
else 
    dbms_output.put_line('III stopieñ przypakowania');
end if;
end;
/


begin
    for x in 1..10 loop
    dbms_output.put_line('siema');
    end loop;
    dbms_output.put_line('koniec');
end;
/




begin
    for x in 1..10 loop
        dbms_output.put_line('siema po raz '||x);
    end loop;
    dbms_output.put_line('koniec');
end;
/

/*Zadanie 6.
*. Wyœwietl 20 kolejnych potêg liczby 2
*/

select power(10,3) from dual;
/

begin
for koza in 1..20 loop
    dbms_output.put_line('2^'||koza||'='||power(2,koza));
end loop;
end;
/


declare
wynik number;
begin
for koza in 1..20 loop
    wynik:=power(2,koza);
    dbms_output.put_line('2^'||koza||'='||wynik);
end loop;
end;

/


declare
wynik number;
x integer;
begin
for koza in 1..20  loop
    x:=koza*2;
    wynik:=power(2,x);
    dbms_output.put_line('2^'||x||'='||wynik);
end loop;
end;
/


declare
wynik number;
x integer;
begin
for koza in 20..1  loop --fuuuu
    x:=koza*2;
    wynik:=power(2,x);
    dbms_output.put_line('2^'||x||'='||wynik);
end loop;
end;
/


declare
wynik number;
begin
for koza in  reverse 1..20  loop --fuuuu
    wynik:=power(2,koza);
    dbms_output.put_line('2^'||koza||'='||wynik);
end loop;
end;
/


begin
for x in  -10..10 loop
    if x<0 then
        dbms_output.put_line(x||' jest mniejsze od 0');
    elsif x=0 then 
        dbms_output.put_line(x||' jest zerem');
    else 
        dbms_output.put_line(x||' jest wiêksze od 0');
    end if;
end loop;
end;

/*
7. Wypisz liczby w zakresie 1-100 obok kazdej piszac czy jest parzysta czy nie
*/

select mod(11,2) from dual;
/

begin
for x in 1..100 loop
    if mod(x,2)=0 then 
        dbms_output.put_line(x||' jest parzysta');
    else
        dbms_output.put_line(x||' jest nieparzysta');
    end if;
end loop;
end;
/

--przerwa obiadowa do 13:24

/*
8. Napisz symulator lokaty. Symulator ma przez zmienne przyjac kwote lokowana, ilosc miesiecy 
na ktora zakladamy lokatê i oprocentowanie w skali roku. Zakladamy comiesieczna kapitalizacje 
odsetek. Dla kazdego miesiaca trwania lokaty wyswietl ktory to miesiac i ile mamy odlozone na 
lokacie. 
*/

declare
konto number:=100000;
ilosc_miesiecy integer:=24;
oprocentowanie number:=0.08;
begin
    for m in 1..ilosc_miesiecy loop
        konto:=round(konto+(konto*oprocentowanie/12),2);
        dbms_output.put_line(m||' '||konto);
    end loop;
end;
/


declare
konto number:=100000;
ilosc_miesiecy integer:=24;
oprocentowanie number:=-0.18;
begin
    for m in 1..ilosc_miesiecy loop
        konto:=round(konto+(konto*oprocentowanie/12),2);
        dbms_output.put_line(m||' '||konto);
    end loop;
end;
/

begin
for x in -10..10 loop
    if x=0 then
        continue;
    end if;
    dbms_output.put_line(x||' '||1/x);
end loop;
end;
/

begin
for x in -10..10 loop
    if x=0 then
        exit;
    end if;
    dbms_output.put_line(x||' '||1/x);
end loop;
end;
/


begin
while(1=1) loop
    null;
end loop;
end;
/


declare
suma integer:=1;
x integer:=1;
begin
while(suma<100) loop
    x:=x+1;
    suma:=suma+x;
    dbms_output.put_line('x='||x||' suma='||suma);
end loop;
end;
/


declare 
cursor k is select * from employees;
begin
for w in k loop
    dbms_output.put_line(w.last_name);
end loop;
end;
/

declare
x integer:=0;
begin
loop
x:=x+1;
dbms_output.put_line(x);
exit when x=10;
end loop;
end;

/


declare
x integer:=0;
begin
loop
x:=x+1;
dbms_output.put_line(x);
if x=10 then exit;
end if;
end loop;
end;
/

/*9.
Korzystajac z petli while lub exit when wyswietlaj kolejne potegi liczby dwa az potega nie wyniesie wiecej niz 10000
*/


declare
wynik number:=0;
np integer:=0;
begin
while(wynik<10000) loop
    np:=np+1;
    wynik:=power(2,np);
    dbms_output.put_line(np||' '||wynik);
end loop;
end;
/


declare
wynik number:=0;
np integer:=0;
begin
while(wynik<10000) loop
    dbms_output.put_line(np||' '||wynik);
    np:=np+1;
    wynik:=power(2,np);    
end loop;
end;
/

declare
wynik number:=0;
np integer:=0;
begin
loop
np:=np+1;
wynik:=power(2,np);
exit when wynik>10000;
dbms_output.put_line(wynik);
end loop;
end;
/


/*10.
Napisz program który bêdzie dodawa³ kolejne wartoœci losowe do sumy (wypisuj¹c ile doda³ i ile wynosi suma)
tak d³ugo a¿ suma nie przekroczy wartoœci podanej przez u¿ytkownika (przez zmienna). Wartoœæ losowa:
execute dbms_output.put_line(round(dbms_random.value(1,1000)));
*/


execute dbms_output.put_line(round(dbms_random.value(1,1000)));
/
declare
wylosowane number;
begin
wylosowane:=round(dbms_random.value(1,1000));
dbms_output.put_line(wylosowane);
end;
/

declare
suma number:=0;
maksimum integer:=1000;
begin
while suma<=maksimum loop
    suma:=suma+round(dbms_random.value(1,10));
    dbms_output.put_line(suma);
end loop;
end;
/

declare
suma number:=0;
maksimum integer:=1000;
begin
loop
    suma:=suma+round(dbms_random.value(1,10));
    exit when suma>maksimum ;
    dbms_output.put_line(suma);
end loop;
end;
/
declare
suma number:=0;
maksimum integer:=1000;
begin
while suma<=maksimum loop
    dbms_output.put_line(suma);
    suma:=suma+round(dbms_random.value(1,10));    
end loop;
end;
/


declare
suma number:=0;
maksimum integer:=1000;
begin
loop
    suma:=suma+round(dbms_random.value(1,10));    
    if suma>maksimum then exit;
    end if;    
    dbms_output.put_line(suma);
end loop;
end;
/

--przerwa do 14:44

begin
execute immediate 'create index ';
end;
/

select * from employees;

begin
update employees set commission_pct=0.5 where department_id=90;
end;
/

declare
prowizja number:=0.5;
departament integer:=90;
begin
update employees set commission_pct=prowizja where department_id=departament;
end;
/

rollback;
/

declare
prowizja number:=0.5;
departament integer:=90;
begin
update employees set commission_pct=prowizja where department_id=departament;
commit;
end;
/

update employees set salary=1000 where department_id=1;

/
declare
prowizja number:=0.5;
departament integer:=90;
begin
update employees set commission_pct=prowizja where department_id=departament;
dbms_output.put_line('zmiana dotyczyla '||sql%rowcount||' wierszy');
commit;
end;
/

declare
prowizja number:=0.5;
departament integer:=900;
begin
update employees set commission_pct=prowizja where department_id=departament;
dbms_output.put_line('zmiana dotyczyla '||sql%rowcount||' wierszy');
if sql%rowcount=0 then 
    dbms_output.put_line('NIE ZMIENIONO ¯ADNEGO WIERSZA!');
end if;
commit;
end;
/



declare
prowizja number:=0.5;
departament integer:=90;
begin
update employees set commission_pct=prowizja where department_id=departament;
commit;
dbms_output.put_line('zmiana dotyczyla '||sql%rowcount||' wierszy');
end;
/

DECLARE
WIERSZ EMPLOYEES%rowtype;
BEGIN
wiersz.last_name:='Klusiewicz';
dbms_output.put_line(wiersz.last_name);
END;
/

/*11.
Napisz program ktory bedzie dawal podwyzki. Kwota podwyzki oraz numer departamentu dla ktorego 
zostanie zastosowana podwyzka maja zostac podane przez uzytkownika (POPRZEZ ZMIENNE).
Operacja ma byæ zatwierdzona transakcyjnie a na konsoli chcemy jeszcze wyswietlic ilu wierszy dotyczyla zmiana.
*/


desc employees;

alter table employees enable row movement;
flashback table employees to timestamp to_timestamp('14-11-2022 14:00:00','dd-mm-yyyy hh24:mi:ss');
/

declare 
ile number:=1000;
nr_departamentu integer:=90;
begin
update employees set salary=salary+ile where department_id=nr_departamentu;
dbms_output.put_line('zmieniono '||sql%rowcount||' wierszy');
commit;
end;
/


create table owoce(
nr_owocu integer primary key,
nazwa_owocu varchar2(4000)
);


insert into owoce values (1,'Banan');
insert into owoce values (2,'Mandarynka');
select * from owoce;

create sequence moja;

select moja.nextval from dual;

create sequence owocowa start with 3 ;
create sequence owocowa start with 3 increment by 1;

insert into owoce values (owocowa.nextval,'XXXXX');
select * from owoce;


create sequence faktury_seq;

create table faktury (
id_faktury integer primary key,
numer_faktury varchar2(4000)
);

create table produkty_na_fakturach (
id_pnf integer primary key,
nazwa varchar2(4000),
id_faktury integer references faktury(id_faktury)
);

begin
insert into faktury values (faktury_seq.nextval,'01/01/2022');
insert into produkty_na_fakturach values (faktury_seq.nextval,'Bulbulator',);
end;

select owocowa.currval from dual;
select owocowa.nextval from dual;
/

declare
id integer;
begin
id:=faktury_seq.nextval;
insert into faktury values (id,'01/01/2022');
insert into produkty_na_fakturach values (faktury_seq.nextval,'Bulbulator',id);
end;

select * from faktury;
select * from produkty_na_fakturach;



declare
id integer;
begin
insert into faktury values (faktury_seq.nextval,'01/01/2022') returning id_faktury into id;
insert into produkty_na_fakturach values (faktury_seq.nextval,'Bulbulator',id);
commit;
end;
/

select * from regions;
/*12.
Napisz program ktory bedzie dodawal wiersze do tabeli regions. Nazwa regionu ma zostac podana przez 
uzytkownika (przez zmienn¹). Numer regionu ma zostac podany z sekwencji a nastepnie po zapisie wiersza wyswietlony na konsoli.
(Chcemy uzyskac region_id pod jakim wyladowal nowo dodany region)
*/

create sequence reg_seq start with 5;

insert into regions values (reg_seq.nextval,'Sosnowiec');

CREATE SEQUENCE regio start with 5 ;
/

select * from user_sequences;



delete from regions where region_id=5;

create sequence rseq start with 5;

declare
nazwa varchar2(4000):='Sosnowiec';
id integer;
begin
insert into regions(region_id,region_name) values (rseq.nextval, nazwa) returning region_id into id;
dbms_output.put_line('Region '||nazwa||' jest pod id='||id);
end;

insert into regions values (5,'xxx');
insert into regions(region_id,region_name) values (5,'xxxx');

/
declare
nazwa varchar2(4000):='&nazwa_regionu';
id integer;
begin
insert into regions(region_id,region_name) values (rseq.nextval, nazwa) returning region_id into id;
dbms_output.put_line('Region '||nazwa||' jest pod id='||id);
end;
/

declare
najwyzszy integer:=4;
begin
delete from regions where region_id>najwyzszy;
end;
/

select * from regions;

/
declare
nazwisko varchar2(4000);
begin
select last_name into nazwisko from employees where employee_id=198;
dbms_output.put_line(nazwisko);
end;
/
declare
nazwisko varchar2(4000);
imie varchar2(4000);
begin
select last_name,first_name into nazwisko,imie from employees where employee_id=198;
dbms_output.put_line(nazwisko);
dbms_output.put_line(imie);
end;
/



declare
nazwisko varchar2(4000);
imie varchar2(4000);
begin
select last_name,first_name into nazwisko,imie from employees; --fuuu
dbms_output.put_line(nazwisko);
dbms_output.put_line(imie);
end;

/

declare
srednia number;
ilosc integer;
begin
select round(avg(salary)),count(*) into srednia,ilosc from employees;
dbms_output.put_line(srednia);
dbms_output.put_line(ilosc);
dbms_output.put_line(srednia||' '||ilosc);
end;
/
select avg(salary),count(*) from employees;
/


/*13.
 Wczytaj do zmiennej a nastêpnie wyœwietl iloœæ osób w departamencie którego numer zostanie podany 
przez uzytkownika
*/
--
--declare
--x integer:=&something;
--begin
--null;
--end;

declare
nr_departamentu integer:=&numer_departamentu;
ilosc integer;
begin
select count(*) into ilosc from employees where department_id=nr_departamentu;
dbms_output.put_line(ilosc);
end;

/


/*14.
Wczytaj do zmiennych i wyœwietl w osobnych liniach imiê, nazwisko i telefon osoby której numer pracownika poda u¿ytkownik.
*/


declare ---fuuuuuuu zle bo trzy odwolania do tabeli
imie varchar2(4000);
nazwisko varchar2(4000);
telefon varchar2(4000);
id integer:=&numer_pracownika;
begin
select first_name into imie from employees where employee_id=id;
select last_name into nazwisko from employees where employee_id=id;
select phone_number into telefon from employees where employee_id=id;
dbms_output.put_line(imie);
dbms_output.put_line(nazwisko);
dbms_output.put_line(telefon);
end;

/


declare
imie varchar2(4000);
nazwisko varchar2(4000);
telefon varchar2(4000);
id integer:=&numer_pracownika;
begin
select first_name,last_name,phone_number into imie,nazwisko,telefon from employees where employee_id=id;
dbms_output.put_line(imie);
dbms_output.put_line(nazwisko);
dbms_output.put_line(telefon);
end;


/
select * from employees;
/
declare
wiersz employees%rowtype;
begin
select * into wiersz from employees where employee_id=1;
exception
when no_data_found then dbms_output.put_line('nie znaleziono wiersza o takim id');
end;
/

declare
wiersz employees%rowtype;
begin
select * into wiersz from employees where employee_id=1;
exception
when others then dbms_output.put_line(sqlerrm);
end;
/


select * from employees where employee_id=100;
select first_name from employees where employee_id=100;

--blob,clob,nclob

/

/*15.
Wczytaj do zmiennej i wyœwietl na konsoli ró¿nicê pomiêdzy najwy¿szymi i najni¿szymi zarobkami 
w departamencie którego nazwê przekaze u¿ytkownik. Program ma byæ niewra¿liwy na wielkoœæ liter 
w nazwie departamentu.
*/

select * from employees;
select * from departments;

select * from departments where lower(department_name)=lower('MARKETING');

SELECT MAX(SALARY)-MIN(SALARY) FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID) WHERE lower(DEPARTMENT_NAME)=lower('It');

select max(salary)-min(salary) from employees where department_id=(select department_id from departments where lower(department_name)=lower('it'));

declare
nazwa_departamentu varchar2(4000):='&nazwa_departamentu';
roznica number;
begin
select max(salary)-min(salary) into roznica from employees where department_id=(select department_id from departments where lower(department_name)=lower(nazwa_departamentu));
dbms_output.put_line('ró¿nica p³ac dla departamentu '||nazwa_departamentu||' wynosi '||roznica);
end;
/

SELECT MAX(SALARY)-MIN(SALARY) FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID) WHERE lower(DEPARTMENT_NAME)=lower('It');

select max(salary)-min(salary) from employees where department_id=(select department_id from departments where lower(department_name)=lower('it'));
/

alter session set tracefile_identifier='to_ja_jestem_plikiem_ktorego_szukasz';
alter session set sql_trace=true;

create table wielka as select * From employees;

begin
for x in 1..14 loop
 insert into wielka select * from wielka;
 commit;
end loop;
end;

declare
cursor k is 
select * from wielka order by last_name;
begin
for w in k loop
null;
end loop;
end;
/

select 504069/17595097 from dual;

--przerwa do 10:29
/

declare
wiersz departments%rowtype;
begin
wiersz.department_name:='Coœtam';
dbms_output.put_line(wiersz.department_name);
end;
/

select * from departments;
/

declare
wiersz departments%rowtype;
begin
select * into wiersz from departments where department_id=90;
dbms_output.put_line(wiersz.department_name);
end;
/


declare
wiersz departments%rowtype;
begin
select * into wiersz from departments where department_id=90;
dbms_output.put_line(upper(wiersz.department_name));
end;
/



/*16.
Wczytaj do zmiennej caly wiersz pracownika ktorego numer poda uzytkownik. Nastepnie wyswietl
na konsoli imie, nazwisko, wynagrodzenie i datê zatrudnienia pracownika w formacie dd-mm-yyyy z wiersza.
*/


select * from employees;
select to_char(sysdate,'dd-mm-yyyy'),sysdate from dual;

alter SESSION  set NLS_DATE_FORMAT = 'dd-mm-yyyy';
/
declare
wiersz employees%rowtype;
nr_pracownika integer:=&numer_pracownika;
begin
select * into wiersz from employees where employee_id=nr_pracownika;
dbms_output.put_line(wiersz.first_name);
dbms_output.put_line(wiersz.last_name);
dbms_output.put_line(wiersz.salary);
dbms_output.put_line(to_char(wiersz.hire_date,'dd-mm-yyyy'));
end;

/

execute dbms_output.put_line('coœ'||chr(13)||'coœ jeszcze');
/


declare
type rekordowy is record(
 nazwisko varchar2(4000),
 departament varchar2(4000)
);
rek rekordowy;
begin
select last_name,department_name into rek from employees join departments using(department_id) where employee_id=100;
dbms_output.put_line(rek.nazwisko);
dbms_output.put_line(rek.departament);
end;
/



declare
type rekordowy is record(
 nazwisko employees.last_name%type,
 departament varchar2(4000)
);
rek rekordowy;
begin
select last_name,department_name into rek from employees join departments using(department_id) where employee_id=100;
dbms_output.put_line(rek.nazwisko);
dbms_output.put_line(rek.departament);
end;
/

desc employees;
/

/*17.
Wczytaj do zmiennej typu rekordowego zaokraglona srednia, minimum i maksimum zarobkow
w departamencie ktorego numer zostanie podany przez uzytkownika. Wczytane dane wyswietl na konsoli
*/

declare
type rekordowy is record(
srednia number,
minimum number,
maksimum number
);
rek rekordowy;
begin
select round(avg(salary)),min(salary),max(salary) into rek from employees where department_id=&numer_departamentu;
dbms_output.put_line('srednia='||rek.srednia);
dbms_output.put_line('minimum='||rek.minimum);
dbms_output.put_line('maksimum='||rek.maksimum);
end;
/

declare
cursor k is select * from employees;
begin
for w in k loop
    dbms_output.put_line(w.first_name||' '||w.last_name);
end loop;
end;
/


declare
cursor k is select first_name,last_name from employees;
begin
for w in k loop
    dbms_output.put_line(w.first_name||' '||w.last_name);
end loop;
end;
/

select * from employees;
drop index emp_name_ix;
select firsT_name,last_name from employees;
create index omg_wtf on employees(last_name,first_name);

select * from employees where department_id=90;

create index abc on employees(department_id);

select department_id,rowid from employees order by 1;
select * from employees where rowid in  ('AAAR6YAAEAAALBeAAE','AAAR6YAAEAAALBeAAD');
/



declare
cursor k is 
select first_name,last_name,job_title from employees join jobs using(job_id);
begin
for w in k loop
    dbms_output.put_line(w.first_name||' '||w.last_name||' '||w.job_title);
end loop;
end;
/


begin
 for w in (select last_name from employees) loop
    dbms_output.put_line(w.last_name);
 end loop;
end;
/


declare
cursor k is 
select first_name,last_name,job_title from employees join jobs using(job_id);
begin
for w in k loop
    dbms_output.put_line(w.first_name||' '||w.last_name||' '||w.job_title);
end loop;
end;
/

declare
cursor k is 
select first_name,last_name,job_title from employees join jobs using(job_id);
w k%rowtype;
begin
open k;
loop
    fetch k into w;
    exit when k%notfound;
    dbms_output.put_line(w.first_name||' '||w.last_name||' '||w.job_title);
end loop;    
close k;
end;
/

declare
cursor k is select * from employees;
type tablica is table of k%rowtype index by binary_integer;
tab tablica;
begin
open k;
fetch k bulk collect into tab;
close k;
dbms_output.put_line(tab.count);
end;
/


/*18.
Korzystajac z kursora wyœwietl na konsoli nazwiska, daty zatrudnienia w formacie dd-mm-yyyy
 i nazwy departamentów wszystkich pracowników
*/

select first_name,last_name,job_title,job_id from employees join jobs using(job_id);
select first_name,last_name,job_title,e.job_id from employees e join jobs j on e.job_id=j.job_id;


create table employees2 as select * from employees;
create table jobs2 as select * from jobs;

select first_name,last_name,job_title from employees2 join jobs2 using(job_id);
create index pierwszy on employees2(job_id,first_name,last_name);
create index drugi on jobs2(job_id,job_title);


select * from wielka;
select count(*) from wielka;
update wielka set salary=salary+1;

/
declare
cursor k is 
select last_Name,to_char(hire_date,'dd-mm-yyyy') data_zatr,department_name  from employees join departments using(department_id);
begin
for w in k loop
    dbms_output.put_line(w.last_name||' '||w.data_zatr||' '||w.department_name);
end loop;
end;
/


declare
cursor k is 
select last_Name,hire_date,department_name  from employees join departments using(department_id);
begin
for w in k loop
    dbms_output.put_line(w.last_name||' '||to_char(w.hire_date,'dd-mm-yyyy')||' '||w.department_name);
end loop;
end;
/


--przerwa do 11:58


/*19.
Korzystaj¹c z kursora wyœwietl nazwy departamentów i liczbê pracowników w nich. Wynik powinien byæ posortowany
malej¹co po liczbie pracowników.
*/


declare
cursor k is 
select department_name, count(*) ilosc from employees join departments using(department_id) group by department_name 
order by 2 desc;
begin
for w in k loop
    dbms_output.put_line(w.department_name||' '||w.ilosc);
end loop;
end;
/


select count(*) from employees where department_id=90;
select last_name,first_name from employees where department_id=90;
create index rotfl on employees(department_id,last_name,first_name);

/
declare
cursor k is select last_name,first_name from employees where department_id=90;
w k%rowtype;
begin
open k;
fetch k into w;
dbms_output.put_line(w.first_name);
fetch k into w;
dbms_output.put_line(w.first_name);
close k;
end;
/



/*20.
 Napisz program który odbierze od u¿ytkownika  numer departamentu,
 wyœwietli na konsoli liczbê pracowników w tym departamencie, a poni¿ej wyœwietli 
listê imion i nazwisk osób z tego departamentu.
*/

declare
ilosc integer;
nd integer:=&numer_departamentu;
cursor k is
select last_name,first_name from employees where department_id=nd;
begin
select count(*) into ilosc from employees where department_id=nd;
dbms_output.put_line('iloœæ pracowników w departamencie '||nd||' wynosi '||ilosc);
for w in k loop
    dbms_output.put_line(w.first_name||' '||w.last_name);
end loop;
end;
/


declare
nd integer:=90;
cursor k is select * from employees where department_id=nd;
begin
for w in k loop
    dbms_output.put_line(w.last_name);
end loop;
end;
/


declare
cursor k(nd integer) is select * from employees where department_id=nd;
begin
for w in k(90) loop
    dbms_output.put_line(w.last_name);
end loop;
end;
/

begin
    for y in 1..10 loop
        for x in 1..10 loop
            dbms_output.put_line('y='||y||' x='||x);
        end loop;
    end loop;
end;
/

/*21.
Wyœwietl nazwy wszystkich departamentów a po ka¿dej nazwie departamentu listê
imion i nazwisk osób w nich zatrudnionych. PodpowiedŸ: powinny byæ dwa kursory z czego jeden sparametryzowany.
*/

declare
cursor kursor_departamenty is select department_id,department_name from departments
where department_id in (select department_id from employees);
cursor kursor_pracownicy(did integer) is select last_name,first_name from employees where department_id=did;
begin
for d in kursor_departamenty loop
    dbms_output.put_line('###### '||d.department_name);
    for p in kursor_pracownicy(d.department_id) loop
        dbms_output.put_line(p.firsT_name||' '||p.last_Name);            
    end loop;
end loop;
end;
/




declare
did integer;
cursor kursor_departamenty is select department_id,department_name from departments
where department_id in (select department_id from employees);
cursor kursor_pracownicy is select last_name,first_name from employees where department_id=did;
begin
for d in kursor_departamenty loop
    dbms_output.put_line('###### '||d.department_name);
    did:=d.department_id;
    for p in kursor_pracownicy loop
        dbms_output.put_line(p.firsT_name||' '||p.last_Name);            
    end loop;
end loop;
end;
/

declare
cursor kursor_departamenty is select department_id,department_name from departments
where department_id in (select department_id from employees);
begin
for d in kursor_departamenty loop
    dbms_output.put_line('###### '||d.department_name);    
    for p in (select last_name,first_name from employees where department_id=d.DEPARTMENT_ID) loop
        dbms_output.put_line(p.firsT_name||' '||p.last_Name);            
    end loop;
end loop;
end;
/

--PRZERWA OBIADOWA DO 13:36

/*22.
Wyœwietl wynik dzielenia 1 przez kolejne liczby z zakresu -10 do 10. 
*/

begin
for x in -10..10 loop
    dbms_output.put_line(x||' '||1/x);
end loop;
end;

/


begin
dbms_output.put_line(1/0);
exception
when others then dbms_output.put_line('wyj¹tek: '||sqlerrm||' '||sqlcode);
end;

/


begin
dbms_output.put_line(1/0);
exception
when invalid_cursor then dbms_output.put_line('To siê nie ma prawa zdarzyc'); 
when zero_divide then dbms_output.put_line('dzielenie przez zero!'); 
when others then dbms_output.put_line('wyj¹tek: '||sqlerrm||' '||sqlcode);
end;

/



begin
dbms_output.put_line(1/0);
dbms_output.put_line('coœtam dalej');
exception
when invalid_cursor then dbms_output.put_line('To siê nie ma prawa zdarzyc'); 
when zero_divide then dbms_output.put_line('dzielenie przez zero!'); 
when others then dbms_output.put_line('wyj¹tek: '||sqlerrm||' '||sqlcode);
end;
/


begin
    begin
        dbms_output.put_line(1/0);
    exception
        when invalid_cursor then dbms_output.put_line('To siê nie ma prawa zdarzyc'); 
        when zero_divide then dbms_output.put_line('dzielenie przez zero!'); 
        when others then dbms_output.put_line('wyj¹tek: '||sqlerrm||' '||sqlcode);        
    end;
dbms_output.put_line('coœtam dalej');
end;

/*23.
Wyœwietl wynik dzielenia 1 przez kolejne liczby w zakresue -10 do 10, tak by 
w przypadku pojawienia siê wyjatku nie przerywac dzialania pêtli
a jedynie wyswietlic przy jakiej wartosci i jaki wyjatek sie pojawil.
*/
/
begin
for x in -10..10 loop
dbms_output.put_line(x||' '||1/x);
end loop;
exception ---fuuuuu, nie w tym miejscu!
when zero_divide then dbms_output.put_line('nie dziel przez zero');
end;
/


begin
for x in -10..10 loop
    begin
        dbms_output.put_line(x||' '||1/x);
    exception --- om nom nom
        when zero_divide then dbms_output.put_line('nie dziel przez zero na '||x);
    end;
end loop;
end;
/

/*24.
Wczytaj do zmiennych i wyœwietl dane (imie,nazwisko,telefon,email) osoby której numer zostanie podany przez u¿ytkownika.
Obs³u¿ wyj¹tek który pojawia siê gdy podasz id nieistniej¹cego pracownika. Obs³uga wyj¹tku powinna sprowadzaæ
siê do wyswietlenia stosownego komunikatu na konsoli.
*/

--https://jsystems.pl/temp/adminka.pdf
--https://jsystems.pl/temp/tuning.pdf
--https://blog.jsystems.pl/show_post/Bezp%C5%82atny_kurs_Python_od_podstaw/

--no_data_found

/
declare
wiersz employees%rowtype;
np integer:=&numer_pracownika;
begin
select * into wiersz from employees where employee_Id=np;
dbms_output.put_line(wiersz.first_name);
dbms_output.put_line(wiersz.last_name);
dbms_output.put_line(wiersz.phone_number);
dbms_output.put_line(wiersz.email);
exception 
when NO_DATA_FOUND then dbms_output.put_line('nie ma pracownika o numerze '||np);
end;
/

begin
raise_application_error(-20001,'kij ci w oko!');
end;
/

begin
raise no_data_found;
end;
/

declare
wyjatek exception;
pragma exception_init(wyjatek,-20001);
begin
raise_application_error(-20001,'kij ci w oko!');
exception
when wyjatek then dbms_output.put_line('abc...');
end;
/

--przerwa do 14:50


create or replace procedure odpal_mnie is 
begin
dbms_output.put_line('siema, to ja!');
end;

--Maciej Aniserowicz devstyle.pl - kurs git 


execute odpal_mnie;

begin
odpal_mnie;
end;
/


create or replace procedure odpal_mnie is 
zmienna integer;
x number;
y date;
begin
dbms_output.put_line('siema, to ja!');
end;
/

create or replace procedure jedz_owoc(nazwa varchar2) is 
begin
 dbms_output.put_line('om nom nom '||nazwa);
end;
/

execute jedz_owoc('banan');

/


create or replace procedure jedz_owoc(nazwa varchar2) is 
begin
 dbms_output.put_line('om nom nom '||nazwa);
end;
/


/*
25.
Napisz procedurê która przyjmie  przez argumenty imiê i nazwisko i wydrukuje na konsoli 
powitanie typu "Witaj TwojeImie TwojeNazwisko".
*/

create or replace procedure witacz(imie varchar2,nazwisko varchar2) is
begin
    dbms_output.put_line('Witaj '||imie||' '||nazwisko||'!');
end;
/

execute witacz('Andrzej','Klusiewicz');

/*26.
Napisz procedurê która przyjmie wzrost i masê a wyœwietli na konsoli obiczone i zaokraglone
do 2 miejsc po przecinku bmi. Obs³u¿ ewentualny wyj¹tek który mo¿e siê pojawiæ gdy podasz wzrost zero.
*/

create or replace procedure da_fuq(x number) is
begin
null;
end;
/
execute da_fuq(1.7);

DECLARE 
COS NUMBER:=1.7;
begin
da_fuq(COS);
end;
/

create or replace procedure bmi_proc(wzrost number,masa number) is 
bmi number;
begin
    bmi:=round(masa/power(wzrost,2),2);
    dbms_output.put_line('bmi='||bmi);
end;

declare
w number:=1.76;
m number:=72;
begin
bmi_proc(w,m);
end;
/


create or replace procedure bmi_proc(wzrost number,masa number) is 
bmi number;
begin
    bmi:=round(masa/power(wzrost,2),2);
    dbms_output.put_line('bmi='||bmi);
exception
when zero_divide then dbms_output.put_line('poda³eœ zerowy wzrost');
end;
/
--
declare
w number:=0;
m number:=72;
begin
bmi_proc(w,m);
end;
/

/*27.
Napisz procedurê która wypisze imiona i nazwiska osób z dzialu ktorego numer zostanie
podany przy wywolaniu jako argument procedury.
*/


create or replace procedure lista_osob(nd integer) is 
cursor k is select first_name,last_name from employees where department_id=nd;
begin
for w in k loop
    dbms_output.put_line(w.first_name||' '||w.last_name);
end loop;
end;
/

execute lista_osob(90);
/

create or replace procedure lista_osob(nd integer) is 
cursor k is select first_name,last_name from employees where department_id=nd;
ilosc integer;
begin
select count(*) into ilosc from employees where department_id=nd;
if ilosc=0 then 
    raise_application_error(-20001,'nie ma osób w tym dziale');
end if;
for w in k loop
    dbms_output.put_line(w.first_name||' '||w.last_name);
end loop;
end;
/

execute lista_osob(90);
execute lista_osob(0);

/

create or replace procedure lista_osob(nd integer) is 
cursor k is select first_name,last_name from employees where department_id=nd;
ilosc integer;
begin
for w in k loop
    dbms_output.put_line(k%rowcount||' '||w.first_name||' '||w.last_name);
end loop;
end;
/


create or replace procedure lista_osob(nd integer) is 
cursor k is select first_name,last_name from employees where department_id=nd;
ilosc integer:=0;
begin
for w in k loop
    ilosc:=k%rowcount;
    dbms_output.put_line(k%rowcount||' '||w.first_name||' '||w.last_name);
end loop;
if ilosc=0 then
    dbms_output.put_line('nie ma osób w tym dziale');
end if;
end;
/

execute lista_osob(90);
execute lista_osob(9);


create or replace procedure lista_osob(nd integer) is 
cursor k is select first_name,last_name from employees where department_id=nd;
ilosc integer:=0;
ok integer:=0;
begin
for w in k loop
    ok:=1;
    dbms_output.put_line(k%rowcount||' '||w.first_name||' '||w.last_name);
end loop;
if ilosc=0 then
    dbms_output.put_line('nie ma osób w tym dziale');
end if;
end;


/

/*28.
Napisz procedurê która przyjmie przez argumenty numer dzialu i podwyzkê. Procedura
ma dac podwy¿kê osobom z dzialu ktorego numer zostanie podany przy wywolaniu (podobnie jak podwyzka).
Jeœli podwy¿ka nie zostanie zastosowana na ¿adnym wierszu, chcemy wywo³aæ wyj¹tek z odpowiednim komunikatem.
Zmiany wprowadzone przez tê procedurê maja byc utrwalone transakcyjnie.
*/

update employees set salary=salary+1000 where department_id=1;

execute podwyzka(90,1000);

create or replace procedure podwyzka(nd integer,ile number) is
begin
update employees set salary=salary+ile where department_id=nd;
if sql%rowcount=0 then
    raise_application_error(-20001,'Nikt nie dosta³ podwy¿ki');
end if;
commit;
end;

execute podwyzka(0,1000);
/


/*
29. Napisz procedurê która przyjmie numer departamentu a wyœwietli na konsoli 
nazwê tego departamentu, srednia zarobkow w nim zaokraglona do 2 miejsc po 
przecinku, ilosc pracownikow w nich. Wszystko w osobnych liniach ze stosownym opisem
np. Nazwa departamentu=IT
*/

select department_name from departments where department_id=90;
select avg(salary) from employees where department_id=90;
select count(*) from employees where department_id=90;



select department_name from departments where department_id=90;
select count(*),avg(salary) from employees where department_id=90;

select department_name,round(avg(salary),2), count(*) from employees join departments
using(department_id)
where department_id=90
group by department_name;
/
create or replace procedure statystyki(did integer)is
nazwa departments.department_name%type;
srednia number;
liczba integer;
begin
select department_name,round(avg(salary),2), count(*) 
into nazwa,srednia,liczba
from employees join departments
using(department_id)
where department_id=did
group by department_name;
dbms_output.put_line('nazwa departamentu='||nazwa);
dbms_output.put_line('œrednia zarobków='||srednia);
dbms_output.put_line('liczba pracowników='||liczba);
exception 
when no_data_found then dbms_output.put_line('nie ma takiego departamentu');
end;
/
execute statystyki(90);
execute statystyki(0);
/


begin
for x in 1..10 loop
sys.dbms_session.sleep(1);
dbms_output.put_line('x='||x);
end loop;
end;
/

/

--przerwa do 10:47

/*30.
Napisz procedurê która bêdzie przyjmowa³a nazwê pakietu, nazwê procedury lub funkcji, informacjê o zdarzeniu przez argument i zapisywa³a do 
osobnej tabelki wiersz zawierajacy klucz glowny, timestamp zdarzenia, u¿ytkownika wywo³uj¹cego procedurê oraz
informacje przekazane przez argumenty
log('jakas informacja')
*/

create sequence log_seq;

create table logs(
log_id integer primary key,
log_timestamp timestamp not null,
logged_user varchar2(30) not null,
package_name varchar2(4000) not null,
function_name varchar2(4000) not null,
info clob
);

select user from dual;
select systimestamp from dual;

begin
zalogowany:=user;
end;

execute log('nazwa_pakietu','nazwa_procedury/funkcji','operacja przebiegla pomyslnie');

insert into tabela values (nazwa_sekwencji.nextval, );

/
--__name__

create or replace procedure wow is 
begin
dbms_output.put_line($$PLSQL_UNIT);
end;
/
execute wow;

create or replace package omg is
procedure wow;
end;
/
create or replace package body omg is 
procedure wow is 
begin
dbms_output.put_line($$PLSQL_UNIT);
end;
end;
/
execute omg.wow;

execute loguj('pakiet_etl','oczyszczanie_danych','');


/*30.
Napisz procedurê która bêdzie przyjmowa³a nazwê pakietu, nazwê procedury lub funkcji, informacjê o zdarzeniu przez argument i zapisywa³a do 
osobnej tabelki wiersz zawierajacy klucz glowny, timestamp zdarzenia, u¿ytkownika wywo³uj¹cego procedurê oraz
informacje przekazane przez argumenty
log('jakas informacja')
*/

create sequence log_seq;

create table logs(
log_id integer primary key,
log_timestamp timestamp not null,
logged_user varchar2(30) not null,
package_name varchar2(4000) not null,
function_name varchar2(4000) not null,
info clob
);

create or replace procedure loguj(nazwa_pakietu varchar2,nazwa_procedury varchar2,info_about clob) is
begin
insert into logs(log_id,log_timestamp,logged_user,package_name,function_name,info) 
values (log_seq.nextval,systimestamp,user,nazwa_pakietu,nazwa_procedury,info_about);
end;
/

execute loguj('ETL','CLEAN_DATA','wszystko siê uda³o');
select * from logs;

a;
loguj(.....)
b;
loguj(.....)
c;
loguj(.....)
d;
loguj(.....)
/


create or replace procedure loguj(nazwa_pakietu varchar2,nazwa_procedury varchar2,info_about clob) is
pragma autonomous_transaction;
begin
insert into logs(log_id,log_timestamp,logged_user,package_name,function_name,info) 
values (log_seq.nextval,systimestamp,user,nazwa_pakietu,nazwa_procedury,info_about);
commit;
end;
/

select * from employees;
update employees set salary=1000;

execute loguj('XI','JINGPING','wprowadzono komunizm');
select * from logs;
rollback;


begin
for x in 1..10 loop
sys.dbms_session.sleep(1);
--dbms_output.put_line('x='||x);
loguj('XI','JINGPING','x='||x);
end loop;
end;
/

--przerwa do 12:03

/

select salary from employees;

create or replace function brutto(netto number) return number is
begin
return round(netto*1.23,2);
end;
/

create or replace function brutto(netto number) return number is
wynik number;
begin
wynik:=round(netto*1.23,2);
return wynik;
null;
end;
/

select salary,brutto(salary) from employees;



/
create or replace function wiele_returnow(x integer) return varchar2 is
begin
if x=1 then
    return 'jeden';
elsif x=2 then 
    return 'dwa';
else 
    return 'poza zakresem';
end if;
end;
/
select wiele_returnow(1) from dual;
select wiele_returnow(3) from dual;
/

select last_name,months_between(sysdate, hire_date) from employees;

/

create or replace function years_between(d1 date,d2 date) return number is 
begin
return months_between(d1,d2)/12;
end;
/

select last_name,months_between(sysdate, hire_date),years_between(sysdate,hire_date) from employees;

grant execute on brutto to hr;

select hr.brutto(1) from dual;

begin
procedura;
end;

execute procedura;

execute brutto(1); ---fuuu

select brutto(1) from dual;
/
declare
wynik number;
begin
wynik:=brutto(1);
dbms_output.put_line(wynik);
end;
/

begin
dbms_output.put_line(brutto(1));
end;
/

/*31.
napisz funkcjê która odbierze przez argumenty wzrost i masê a zwróci obliczone bmi.
*/

create or replace function funkcja return integer is 
begin
dbms_output.put_line('dupa!');
return 1;
end;
/

select funkcja from dual;

execute dbms_output.put_line('ok');

create or replace function bmi(w number,m number) return number is 
begin
    return round(m/power(w,2),2);
end;

select bmi(1.76,80) from dual;
select bmi(0,80) from dual;

/


create or replace function bmi(w number,m number) return number is 
begin
    return round(m/power(w,2),2);
exception 
when zero_divide then dbms_output.put_line('wzrost jest równy zero');
return -1;
end;
/
select bmi(0,80) from dual;

execute dbms_output.put_line('ok');


/*32.
napisz funkcjê która przyjmie datê a zwróci z niej tylko rok. Przetestuj jej dzialanie na kolumnie hire_date
*/

select to_char(sysdate,'yyyy') from dual;

select last_name,hire_date,rok(hire_date) from employees;


create or replace function rok(d date) return number is
begin
return to_char(d,'yyyy');
end;
/

select last_name,hire_date,rok(hire_date) from employees;


select rok(to_date('16-11-2022','dd-mm-yyyy')) from dual;

/*33.
Napisz funkcjê która zwróci ilosc pracownikow w departamencie ktorego numer
zostanie podany przez argument tej funkcji.
*/

create or replace procedure print(x varchar2) is 
begin
dbms_output.put_line(x);
end;
/

execute print('dupa');
/

create or replace function ile_pracownikow(did integer) return integer is 
x integer;
begin
    select count(*) into x from employees where department_id=did;
    return x;
end;

select ile_pracownikow(90) from dual;
select ile_pracownikow(0) from dual;
/



create or replace function ile_pracownikow(did integer) return integer is 
x integer;
y integer;
begin
    select count(*) into y from departments where department_id=did;
    if y=0 then
        raise_application_error(-20001,'nie ma takiego dzia³u');
    end if;
    select count(*) into x from employees where department_id=did;
    return x;
end;
/

select ile_pracownikow(0) from dual;
/

/*34.
Napisz funkcjê która zwróci jeden wiersz pracownika którego numer zostanie podany 
przez argument funkcji. Odbierz ten wiersz w bloku anonimowym i wyœwietl z niego na konsoli imiê, nazwisko i numer telefonu.
Ogarnij tez sytuacje gdy ktos poda id nieistniejacego pracownika.
*/

create or replace function pracownik(eid integer) return employees%rowtype is 
wiersz employees%rowtype;
begin
select * into wiersz from employees where employee_id=eid;
return wiersz;
exception 
when no_data_found then return wiersz;
end;
/
declare
wiersz employees%rowtype;
begin
wiersz:=pracownik(100);
print('########################');
print(wiersz.first_name);
print(wiersz.last_name);
print(wiersz.phone_number);
print('########################');
end;
/


--przerwa obiadowa do 14:00


--a-->b-->c
--
--extract;
--transform;
--load;

--odpal_ten_stuff;


create or replace package pakiecik is 
procedure witacz;
procedure witacz(imie varchar2);
function dajkoze return varchar2;
end;
/

create or replace package body pakiecik is 
procedure witacz is 
begin
    dbms_output.put_line('siema!');
end;

procedure witacz(imie varchar2) is 
begin
    dbms_output.put_line('Witaj '||imie||'!');
end;


function dajkoze return varchar2 is 
begin
return 'koza';
end;

end;
/

execute pakiecik.witacz;
execute pakiecik.witacz('Andrzej');
select pakiecik.dajkoze from dual;

select round(10/3),round(10/3,2) from dual;

/*35.
Stwórz pakiet który bêdzie posiadal 2 funkcje. Jedna przyjmuje wzrost i mase a zwraca bmi,
a druga przyjmuje bmi a zwraca opis dla bmi (niedowaga, nadwaga etc). Przetestuj dzialanie funkcji.
*/

create or replace package cwiczenie35 is
function bmi(w number,m number) return number;
function opis_bmi(b number) return varchar2;
end;
/

create or replace package body cwiczenie35 is 
function bmi(w number,m number) return number is
begin
    return round(m/power(w,2),2);
end;

function opis_bmi(b number) return varchar2 is
begin
if b<16 then
    return 'wyglodzenie';
elsif b<17 then 
    return 'wychudzenie';
elsif b<18.5 then 
    return 'niedowaga';
elsif b<25 then 
    return 'masa ok';
elsif b<30 then
    return 'nadwaga';
elsif b<35 then
    return 'I stopieñ przypakowania';
elsif b<40 then 
    return 'II stopieñ przypakowania';
else 
    return 'III stopieñ przypakowania';
end if;
end;
end;
/
select cwiczenie35.opis_bmi( cwiczenie35.bmi(1.76,80)  ) from dual;
select cwiczenie35.bmi(1.76,80) from dual;
select cwiczenie35.opis_bmi(26) from dual;

/*36.
Stwórz pakiet który bêdzie posiada³ dwie przeci¹¿one procedury o nazwie statystyka. Jedna z procedur
ma nie przyjmowaæ ¿adnego argumentu, druga ma przyjmowaæ argument bêd¹cy liczb¹ ca³kowit¹. Pierwsza ma wydrukowaæ
na konsoli œrednie, maksymalne i minimalne zarobki w ca³ej firmie, druga te same dane ale dla dzia³u którego
numer zostanie podany przez argument tej procedury.
*/
/
create or replace package cwiczenie36 is
procedure statystyka;
procedure statystyka(nr_dep integer);
end;
/

create or replace package body cwiczenie36 is
procedure statystyka is
srednia number;
maksi number;
mini number;
begin
select avg(salary), max(salary),min(salary) into srednia,maksi,mini from employees;
dbms_output.put_line('srednia='||srednia);
dbms_output.put_line('minimalne='||mini);
dbms_output.put_line('maksymalne='||maksi);
end;

procedure statystyka(nr_dep integer) is
srednia number;
maksi number;
mini number;
begin
select avg(salary), max(salary),min(salary) into srednia,maksi,mini from employees where department_id=nr_dep;
dbms_output.put_line('srednia='||srednia);
dbms_output.put_line('minimalne='||mini);
dbms_output.put_line('maksymalne='||maksi);
end;

end;

/

execute cwiczenie36.statystyka;
execute cwiczenie36.statystyka(90);
/

create or replace package load_warehouse is
procedure extract;
procedure transform;
procedure load;
end;
/

create or replace package body load_warehouse is 
procedure extract is 
begin
dbms_output.put_line('ekstrakcja danych');
end;
procedure transform is
begin
dbms_output.put_line('transformacja i oczyszczanie danych');
end;
procedure load is
begin
dbms_output.put_line('ladowanie danych');
end;
end;
/

begin
load_warehouse.extract;
--load_warehouse.transform;
load_warehouse.load;
end;
/



create or replace package load_warehouse is
--procedure extract;
--procedure transform;
--procedure load;
procedure run_this_stuff;
end;
/

create or replace package body load_warehouse is 

procedure extract is 
begin
dbms_output.put_line('ekstrakcja danych');
end;
procedure transform is
begin
dbms_output.put_line('transformacja i oczyszczanie danych');
end;
procedure load is
begin
dbms_output.put_line('ladowanie danych');
end;

procedure run_this_stuff is
begin
    extract;
    transform;
    load;
end;

end;
/

begin
load_warehouse.run_this_stuff;
end;
/

/*37.
Stwórz pakiet który bêdzie posiada³ trzy prywatne funkcje - jedna zwracac 
ma srednia zarobkow w firmie, druga ilosc pracownikow
w firmie, trzecia sumê zarobków w firmie. Do pakietu dodaj
te¿ publiczn¹ procedurê która korzystaj¹c z tych funkcji wypisze dane na konsoli
*/


create or replace package cwiczenie37 is
--function srednia return number;
--function ilosc return integer;
--function suma return number;
procedure wypisz;
end;
/
create or replace package body cwiczenie37 is 
function srednia return number is 
x number;
begin
select avg(salary) into x from employees;
return x;
end;
function ilosc return integer is 
x integer;
begin
select count(*) into x from employees;
return x; 
end;
function suma return number is 
x number;
begin
select sum(salary) into x from employees;
return x;
end;

procedure wypisz is 
begin
dbms_output.put_line('srednia='||srednia);
dbms_output.put_line('ilosc='||ilosc);
dbms_output.put_line('suma='||suma);
end;
end;
/
select cwiczenie37.srednia,cwiczenie37.ilosc,cwiczenie37.suma from dual;
execute cwiczenie37.wypisz;

grant execute on cwiczenie37 to hr;

--przerwa do 15:50

/
create or replace trigger prosty 
after update on employees
begin
dbms_output.put_line('update na employees!');
end;
/

update employees set salary=salary+1;

/
create or replace trigger prosty 
after update or delete or insert on employees
begin
if inserting then dbms_output.put_line('to by³ insert');
elsif deleting then dbms_output.put_line('do byl delete');
else dbms_output.put_line('to byl update');
end if;
end;
/

/*38.
Napisz trigger który do osobnej tabelki bêdzie raportowa³ zmiany na tabeli employees. Zapisywane w tej tabelce ma byæ:
- klucz g³ówny
- nazwa tabeli
- uzytkownik zmieniajacy
- rodzaj operacji (update, insert, delete)
- timestamp operacji
*/

create sequence zmiany_seq;

create table zmiany(
id_zmiany integer primary key,
nazwa_tabeli varchar2(4000) not null,
uzytkownik_zmieniajacy varchar2(30) not null,
rodzaj_operacji varchar2(40) not null,
timestamp_operacji timestamp
);

create or replace trigger obserwator_zmian 
after update or delete or insert on employees
declare
operacja zmiany.rodzaj_operacji%type;
begin
if inserting then operacja:='insert';
elsif deleting then operacja:='delete';
else operacja:='update';
end if;
insert into zmiany(id_zmiany,nazwa_tabeli,uzytkownik_zmieniajacy,rodzaj_operacji,timestamp_operacji)
values (zmiany_seq.nextval,'employees',user,operacja,systimestamp);
end;
/

update employees set salary=salary+1;


select * from zmiany;

/
create or replace trigger zmiany_nazwisk 
after update on employees 
for each row
begin
dbms_output.put_line('zmiana wiersza');
end;
/


update employees set salary=salary+1;

/

create or replace trigger zmiany_nazwisk 
after update on employees 
for each row
begin
dbms_output.put_line('stare nazwisko='||:old.last_name);
dbms_output.put_line('nowe nazwisko='||:new.last_name);
end;
/

update employees set last_name='Kowalski' where department_id=90;
rollback;
update employees set salary=salary+1;
/


create or replace trigger zmiany_nazwisk 
after update on employees 
for each row
begin
if :old.last_name<>:new.last_name then  ---fuuuuuuu
    dbms_output.put_line('stare nazwisko='||:old.last_name);
    dbms_output.put_line('nowe nazwisko='||:new.last_name);
end if;
end;
/


create or replace trigger zmiany_nazwisk 
after update of last_name on employees 
for each row
begin
    dbms_output.put_line('stare nazwisko='||:old.last_name);
    dbms_output.put_line('nowe nazwisko='||:new.last_name);
end;
/


update employees set last_name='Kowalski' where department_id=90;
rollback;
update employees set salary=salary+1;
select * from employees;

select * from user_triggers;

create or replace trigger zmiany_nazwisk 
after update on employees 
for each row
when(to_char(sysdate,'d') in (1,2,3))
begin
    dbms_output.put_line('stare nazwisko='||:old.last_name);
    dbms_output.put_line('nowe nazwisko='||:new.last_name);
end;
/


create or replace trigger zmiany_nazwisk 
after update on employees 
for each row
when(new.last_name<>old.last_name)
begin
    dbms_output.put_line('stare nazwisko='||:old.last_name);
    dbms_output.put_line('nowe nazwisko='||:new.last_name);
end;
/

/*39.
Stwórz trigger który bêdzie w przypadku zmiany wynagrodzeñ w employees odkladal w osobnej tabelce informacje
o tym któremu pracownikowi, z jakiego wynagrodzenia, na jakie wynagrodzenie kiedy zmieniono wynagrodzenie i kto zmienial.
*/

create table zmiany_wynagrodzen(
id_zw integer primary key,
employee_Id integer references employees(employee_Id),
stare_wynagrodzenie number not null,
nowe_wynagrodzenie number not null,
moment_zmiany timestamp not null,
zmieniajacy varchar2(30 ) not null
);
/
create sequence zw_seq;
/

create or replace trigger zmiana_hajsu_trigger
after update on employees 
for each row
when(old.salary<>new.salary)
begin

end;
/

create or replace trigger zmiana_hajsu_trigger
after update of salary on employees 
for each row
begin
    insert into zmiany_wynagrodzen(id_zw,employee_Id,stare_wynagrodzenie,nowe_wynagrodzenie,moment_zmiany,zmieniajacy)
    values (zw_seq.nextval,:old.employee_Id,:old.salary,:new.salary,systimestamp,user);
end;
/

update employees set salary=salary+133;
select * from zmiany_wynagrodzen;

--klusiewicz@jsystems.pl


create table abc (id integer, tekst varchar2(4000));

create or replace trigger abc_trigger 
before insert on abc
for each row
begin
:new.tekst:='wstawione przez trigger';
end;
/

insert into abc(id) values (10);
select * from abc;

/

/*40.
Stwórz trigger który bêdzie automagicznie uzupe³nia³ wartoœci klucza g³ównego tabeli regions za pomoc¹ sekwencji przy wstawianiu
wiersza do tej tabeli.
*/

select * from regions;
insert into regions(region_name) values ('Radom');

create sequence reg_seq start with 5;

create table regions_andrzej as select * from regions;

select * from user_triggers;
select * from all_triggers;
/
create or replace trigger uzupelniacz 
before insert on regions 
for each row
begin
:new.region_id:=reg_seq.nextval;
end;


insert /*+append*/ into regions(region_name) values ('Radom');

select /*+full(employees)*/last_name from employees;

select * from regions;

delete from regions where region_id not in (select region_id from countries);
select * from regions as of timestamp to_timestamp('17.11.2022 09:34','dd.mm.yyyy hh24:mi');

select * from employees;
update employees set salary=1000;
commit;
select * from employees as of timestamp to_timestamp('17.11.2022 09:34','dd.mm.yyyy hh24:mi');
flashback table employees to timestamp to_timestamp('17.11.2022 09:34','dd.mm.yyyy hh24:mi');

update employees e set salary=
(select salary from employees as of timestamp to_timestamp('17.11.2022 09:34','dd.mm.yyyy hh24:mi') where employee_id=e.employee_id);


/*41.
Stwórz trigger który uniemo¿liwi zmiane wynagrodzenia w tabelce employees na mniejsze ni¿ jest aktualnie.
Trigger ma wyœwietlaæ odpowiedni komunikat a w wierszu przywracaæ stare wynagrodzenie lub uniemo¿liwiaæ jego 
zmianê.
*/
/
create or replace trigger zmniejszanie_pensji
before update on employees
for each row
when (new.salary<old.salary)
begin
raise_application_error(-20001,'sam se zmniejsz pensjê dziadu!');
end;
/


update employees set salary=salary+100 where employee_id=100;
update employees set salary=salary-100 where employee_id=100;

select * from user_triggers;

--przerwa do 10:21

/
declare
type tablica is table of varchar2(400) index by binary_integer;
tab tablica;
begin
tab(1):='nietoperz';
tab(6):='kura';
tab(-70):='indyk';
dbms_output.put_line(tab.first);
dbms_output.put_line(tab(tab.first));
dbms_output.put_line(tab.last);
dbms_output.put_line(tab(tab.last));
dbms_output.put_line(tab.count);
end;
/

declare
type tablica is table of varchar2(4000) index by binary_integer;
koza tablica;
begin
koza(1):='coœ 1';
koza(2):='coœ 2';
koza(3):='coœ 3';
for x in 1..3 loop
    dbms_output.put_line(koza(x));
end loop;
end;
/


declare
type tablica is table of varchar2(4000) index by binary_integer;
koza tablica;
begin
koza(1):='coœ 1';
koza(2):='coœ 2';
koza(3):='coœ 3';
for x in koza.first..koza.last loop
    dbms_output.put_line(koza(x));
end loop;
end;
/


declare
cursor k is select last_name, first_name from employees;
type tablica is table of k%rowtype index by binary_integer;
tab tablica;
begin
    for w in k loop
        tab(k%rowcount):=w;
    end loop;
    for x in tab.first..tab.last loop
        dbms_output.put_line(tab(x).first_name||' '||tab(x).last_name);
    end loop;
end;
/


declare
type tablica is table of varchar2(4000) index by binary_integer;
koza tablica;
tu_jestem integer;
begin
koza(1):='coœ 1';
koza(20):='coœ 2';
koza(300):='coœ 3';
tu_jestem:=koza.first;
for x in 1..koza.count loop
    dbms_output.put_line(koza(tu_jestem));
    tu_jestem:=koza.next(tu_jestem);
end loop;
end;


/*42.
Stwórz tablicê 100 elementów tekstowych. Kazdy element ma zawierac ciag "element numer x" gdzie x bêdzie numerem 
tego elementu. Nastepnie przeiteruj po tablicy i wyswietl po kolei zawartosc wszystkich jej elementów.
*/
/
declare
type tablica is table of varchar2(4000) index by binary_integer;
tab tablica;
begin
for x in 1..100 loop
    tab(x):='element numer '||x;
end loop;
for i in tab.first..tab.last loop
    dbms_output.put_line(tab(i));
end loop;
end;
/


/*43.
Stwórz tablicê zawierajaca 10 kolejnych poteg liczby 2, nastêpnie przeiteruj po tej tablicy i wyswietl jej elementy
*/

declare
type tablica is table of integer index by binary_integer;
tab tablica;
begin
for x in 1..10 loop
      tab(x):=power(2,x);  
end loop;
for x in tab.first..tab.last loop
    dbms_output.put_line(tab(x));
end loop;
end;
/

declare
cursor k is select * from departments;
type tablica is table of departments%rowtype index by binary_integer;
tab tablica;
x integer:=0;
begin
    for w in k loop
    x:=x+1;
    tab(x):=w;
    end loop;
    for i in tab.first..tab.last loop
        dbms_output.put_line(tab(i).department_name);
    end loop;
end;
/



declare
cursor k is select * from departments;
type tablica is table of departments%rowtype index by binary_integer;
tab tablica;
begin
    for w in k loop    
    tab(k%rowcount):=w;
    end loop;
    for i in tab.first..tab.last loop
        dbms_output.put_line(tab(i).department_name);
    end loop;
end;
/


declare
cursor k is select department_name,city from departments join locations using(location_id);
type tablica is table of k%rowtype index by binary_integer;
tab tablica;
begin
    for w in k loop    
    tab(k%rowcount):=w;
    end loop;
    for i in tab.first..tab.last loop
        dbms_output.put_line(tab(i).department_name||' '||tab(i).city);
    end loop;
end;
/

/*
44. Korzystajac z kursora wczytaj dane wszystkich pracownikow do tablicy. Nastepnie przeiteruj 
po tablicy i wyœwietl imiona i nazwiska z jej elementów.
Podpowiedzi:
Mo¿na tak deklarowaæ tablicê :
type tablica is table of employees%rowtype index by binary_integer;
a tak mo¿na w kodzie przypisywaæ:
tab(x):=w
*/


declare
begin
for w in k loop
    tab(k%rowcount):=w;
end loop;
for x in tab.first..tab.last loop
    dbms_output.put_line(tab(x).first_name||' '||tab(x).last_name);
end loop;
end;
/


create or replace package nadane is
cursor k is select * from employees; 
type tablica is table of k%rowtype index by binary_integer;
tab tablica;
end;
/

declare
begin
for w in nadane.k loop
    nadane.tab(nadane.k%rowcount):=w;
end loop;
end;
/

begin
dbms_output.put_line(nadane.tab.count);
end;
/


/*45.
Wczytaj do tablicy wynik zapytania z nazwami departamentow i liczbie pracownikow w nich.
Nastêpnie przeiteruj po tej liœcie i wyœwietl zawartoœæ elementów
*/

declare
cursor k is
select department_name,count(*) liczba from employees join departments using(department_id) group by department_name order by 2 desc;
type tablica is table of k%rowtype index by binary_integer;
tab tablica;
begin
for w in k loop
    tab(k%rowcount):=w;
end loop;
for x in tab.first..tab.last loop
    dbms_output.put_line(tab(x).department_name||' '||tab(x).liczba);
end loop;
end;

--przerwa do 11:33

/
create or replace package typy is
type tablica is table of varchar2(400) index by binary_integer;
end;
/
create or replace function daj_dane return typy.tablica is 
tab typy.tablica;
begin
    for x in 1..10 loop
        tab(x):='element numer '||x;
    end loop;
    return tab;
end;
/

create or replace procedure drukuj_dane(tab typy.tablica) is 
begin
    for x in tab.first..tab.last loop
        dbms_output.put_line(tab(x));
    end loop;
end;
/
execute drukuj_dane(daj_dane);
/
declare
tab typy.tablica;
begin
tab:=daj_dane;
drukuj_dane(tab);
end;
/

/*
46. Napisz funkcjê która zwróci pod postacia tablicy tyle poteg liczby 2 ile podamy przez argument tej funkcji.
W bloku anonimowym odbierz tablice od funkcji i wyswietl jej zawartosc
*/

create or replace package typy is 
type tablica is table of integer index by binary_integer;
end;
/

create or replace function potegi(mv integer) return typy.tablica is 
tab typy.tablica;
begin
    for x in 1..mv loop
        tab(x):=power(2,x);
    end loop;
    return tab;
end;
/

declare
tab typy.tablica;
begin
tab:=potegi(100);
for x in tab.first..tab.last loop
    dbms_output.put_line(tab(x));
end loop;
end;
/

/*47.
Napisz funkcjê która zwróci cala zawartosc tabeli departments w postaci tablicy. Odbierz tablicê i wyswietl jej zawartosc
*/

create or replace package cwiczenie47 is
type tablica is table of departments%rowtype index by binary_integer;
end;
/


create or replace package cwiczenie47 is
cursor k is select * from departments;
type tablica is table of k%rowtype index by binary_integer;
end;
/

create or replace function departamenty return cwiczenie47.tablica is 
tab cwiczenie47.tablica;
begin
for w in cwiczenie47.k loop
    tab(cwiczenie47.k%rowcount):=w;
end loop;
return tab;
end;
/

declare
tab cwiczenie47.tablica;
begin
tab:=departamenty;
for x in tab.first..tab.last loop
    dbms_output.put_line(tab(x).department_name);
end loop;
end;
/

/*48.
Napisz procedurê która przyjmie przez argument tablicê elementów typu employees%rowtype i wyœwietli nazwiska i imiona
z wszystkich elementów. Przetestuj tê procedurê uruchamiajac ja i podajac jej tak¹ tablicê z danymi.
*/

create or replace package cwiczenie48 is
type tablica is table of employees%rowtype index by binary_integer;
end;
/

create or replace procedure cwiczenie48_drukowanie(tab cwiczenie48.tablica) is
begin
    for x in tab.first..tab.last loop
        dbms_output.put_line(tab(x).first_name||' '||tab(x).last_name);
    end loop;
end;
/

declare
cursor k is select * from employees;
tab cwiczenie48.tablica;
begin
for w in k loop
tab(k%rowcount):=w;
end loop;
cwiczenie48_drukowanie(tab);
end;
/




create or replace package cwiczenie48 is
cursor k is select * from employees;
type tablica is table of k%rowtype index by binary_integer;
end;
/

create or replace procedure cwiczenie48_drukowanie(tab cwiczenie48.tablica) is
begin
    for x in tab.first..tab.last loop
        dbms_output.put_line(tab(x).first_name||' '||tab(x).last_name);
    end loop;
end;
/

declare
tab cwiczenie48.tablica;
begin
for w in cwiczenie48.k loop
tab(cwiczenie48.k%rowcount):=w;
end loop;
cwiczenie48_drukowanie(tab);
end;
/

select * from user_source;
/

--PRZERWA OBIADOWA DO 13:04

/*49.
Stwórz funkcjê która zwróci pod postaci¹ zmiennej typu rekordowego sumê, œredni¹ i maksymalne zarobki w calej firmie.
Przetestuj jej dzialanie odbierajac dane i wyswietlajac je na konsoli
*/

create or replace package cwiczenie49 is
type rekordowy is record(
    suma number,
    srednia number,
    maksymalne number
);
end;
/

create or replace function oddaj_rekord return cwiczenie49.rekordowy is 
rek cwiczenie49.rekordowy;
begin
--select sum(salary), avg(salary), max(salary) into rek.suma, rek.srednia,rek.maksymalne from employees;
select sum(salary), avg(salary), max(salary) into rek from employees;
return rek;
end;
/

declare
rek cwiczenie49.rekordowy;
begin
rek:=oddaj_rekord;
dbms_output.put_line(rek.suma||' '||rek.srednia||' '||rek.maksymalne);
end;
/

/*50.
Napisz pakiet który bêdzie zawiera³ funkcjê zwracaj¹c¹ pod postaci¹ tablicy listê departamentów i œrednie zarobki w nich 
zaokr¹glone do 2 miejsc po przecinku. Do pakietu dodaj procedurê która bêdzie w stanie tak¹ tablicê przyj¹æ a która ja
 wydrukuje na konsoli. Napisz blok anonimowy który odbierze dane od funkcji z pakietu i przekaze do procedury z pakietu.
*/

/

create or replace package cwiczenie50 is 
cursor k is
select department_name,round(avg(salary),2) srednia from employees 
join departments using(department_id)
group by department_name
order by 2 desc;

type tablica is table of k%rowtype index by binary_integer;

function daj_dane return tablica;

procedure drukuj_dane(tab tablica);
end;
/

create or replace package body cwiczenie50 is 
function daj_dane return tablica is
tab tablica;
begin
for w in k loop
    tab(k%rowcount):=w;
end loop;
return tab;
end;

procedure drukuj_dane(tab tablica) is 
begin
for x in tab.first..tab.last loop
    dbms_output.put_line(tab(x).department_name||' '||tab(x).srednia);
end loop;
end;
end;
/

declare
tab cwiczenie50.tablica;
begin
tab:=cwiczenie50.daj_dane;
cwiczenie50.drukuj_dane(tab);
end;
/

execute cwiczenie50.drukuj_dane( cwiczenie50.daj_dane );
/



create or replace package zmienne_i_inicjalizacja is 
zmienna varchar2(4000);
end;
/

begin
zmienne_i_inicjalizacja.zmienna:='jakaœ ustawiona wartoœæ';
end;
/

begin
dbms_output.put_line(zmienne_i_inicjalizacja.zmienna);
end;
/


create or replace package zmienne_i_inicjalizacja is 
zmienna varchar2(4000);
end;
/
create  or replace package body zmienne_i_inicjalizacja is 
begin
dbms_output.put_line('inicjalizacja......');
zmienna:='ustawione w inicjalizacji';
end;
/


begin
dbms_output.put_line(zmienne_i_inicjalizacja.zmienna);
end;
/

create or replace package inicjalizacja is
type tablica is table of varchar2(4000) index by binary_integer;
tab tablica;
procedure ile;
end;
/

create or replace package body inicjalizacja is 

procedure ile is
begin
dbms_output.put_line('mamy '||tab.count||' elementow');
end;

begin
for x in 1..10 loop
    tab(x):='element numer '||x;
end loop;
end;
/

execute inicjalizacja.ile;
/

/*51.
Stwórz pakiet zawieraj¹cy tablicê elementów typu employees%rowtype. Zadbaj o to by przy pierwszym odwolaniu 
do pakietu do tej tablicy byly ladowane dane. Dodaj do pakietu procedure ktora wyswietli ile mamy elementów w tablicy.
*/

create or replace package cwiczenie51 is
cursor k is select * from employees;
type tablica is table of k%rowtype index by binary_integer;
tab tablica;
procedure ile;
end;
/

create or replace package body cwiczenie51 is 
procedure ile is 
begin
dbms_output.put_line('ilosc='||tab.count);
end;

begin
for w in k loop
    tab(k%rowcount):=w;
end loop;
end;
/

execute cwiczenie51.ile;
/

--przerwa do 14:44

drop table wielka;
/

create table wielka as select * from employees;
/
begin
for x in 1..14 loop
    insert into wielka select * from wielka;
    commit;
end loop;
end;
/
select count(*) from wielka;
/

/*52.
(preludium do operacji masowych) Wczytaj do tablicy ca³¹ zawartoœæ tabeli wielka wiersz po wierszu. Przed i po ³adowaniu ca³oœci
wyœwietl aktualny czas 
*/
execute dbms_output.put_line(systimestamp);
/



declare
cursor k is select * from wielka;
type tablica is table of wielka%rowtype index by binary_integer;
tab tablica;
begin
dbms_output.put_line(systimestamp);
for w in k loop
    tab(k%rowcount):=w;
end loop;
dbms_output.put_line(systimestamp);
end;
/




declare
cursor k is select * from wielka;
type tablica is table of wielka%rowtype index by binary_integer;
tab tablica;
begin
dbms_output.put_line(systimestamp);
open k;
fetch k bulk collect into tab;
close k;
dbms_output.put_line(systimestamp);
end;
/

insert into wielka select * from wielka;
insert into wielka select * from wielka;
insert into wielka select * from wielka;

select count(*) from wielka;


declare
cursor k is select * from wielka;
type tablica is table of wielka%rowtype index by binary_integer;
tab tablica;
begin
dbms_output.put_line(systimestamp);
open k;
fetch k bulk collect into tab;
close k;
dbms_output.put_line(systimestamp);
end;
/




declare
cursor k is select * from wielka;
type tablica is table of wielka%rowtype index by binary_integer;
tab tablica;
begin
dbms_output.put_line(systimestamp);
open k;
loop
exit when k%notfound;
fetch k bulk collect into tab limit 1000000;
dbms_output.put_line(tab.count); ---tutaj jakies operacje na danych
--zrob_cos_z_danymi(tab);
end loop;
close k;
dbms_output.put_line(systimestamp);
end;
/


create table duza as select * from employees;

/

begin
for x in 1..12 loop
    insert into duza select * from duza;
    commit;
end loop;
end;
/

select count(*) from duza;

insert into duza select * from duza;
commit;
/


declare
type tablica is table of duza%rowtype index by binary_Integer;
tab  tablica;
cursor k is select * from duza;
begin
for w in k loop
    tab(k%rowcount):=w;
end loop;
for x in tab.first..tab.last loop
    insert into pusta values tab(x);
end loop;
commit;
end;

create table pusta as select * from employees where 1=2;
select * from pusta;
/


declare
type tablica is table of duza%rowtype index by binary_Integer;
tab  tablica;
cursor k is select * from duza;
begin
dbms_output.put_line(systimestamp);
for w in k loop
    tab(k%rowcount):=w;
end loop;
---operacje na tablicy
for x in tab.first..tab.last loop
    insert into pusta values tab(x);
end loop;
commit;
dbms_output.put_line(systimestamp);
end;
/

truncate table pusta;
/
declare
type tablica is table of duza%rowtype index by binary_Integer;
tab  tablica;
cursor k is select * from duza;
begin
dbms_output.put_line(systimestamp);
open k;
fetch k bulk collect into tab;
close k;
---operacje na tablicy
forall x in tab.first..tab.last insert into pusta  values tab(x);
commit;
dbms_output.put_line(systimestamp);
end;

select 8/120 from dual;
/

insert into pusta select * from duza;
/

/*53.
 Stwórz pakiet zawieraj¹cy funkcjê która za³aduje do tablicy (i potem zwróci t¹ tablicê)
 za pomoc¹ operacji masowych wynik zapytania zwracajacego listê nazwisk i nazw departamentów z tabel wielka i departments.
Odbierz zwracane przez funkcjê dane w bloku anonimowym i wyswietl ilosc elementow w tablicy.
*/

select last_name,department_name from duza join departments using(department_id);

create or replace package cwiczenie53 is 
cursor k is select last_name,department_name from duza join departments using(department_id);
type tablica is table of k%rowtype index by binary_integer;
function dane return tablica;
end;
/
create or replace package body cwiczenie53 is 
function dane return tablica is 
tab tablica;
begin
open k;
fetch k bulk collect into tab;
close k;
return tab;
end;
end;

/
declare
tab cwiczenie53.tablica;
begin
tab:=cwiczenie53.dane;
dbms_output.put_line(tab.count);
end;
/
--dbeaver


create global temporary table tymczas1(
pole1 varchar2(4000)
);


create global temporary table tymczas2(
pole1 varchar2(4000)
) on commit delete rows;


create global temporary table tymczas3(
pole1 varchar2(4000)
) on commit preserve rows;
/
insert into tymczas1 values ('informacja');
insert into tymczas2 values ('informacja');
insert into tymczas3 values ('informacja');

select * from tymczas1;
select * from tymczas2;
select * from tymczas3;
commit;
/

/*54.
Stwórz tabelê tymczasow¹ zawieraj¹c¹ wynik zapytania zwracaj¹cego nazwy departamentów i liczbê pracowników w nich.
Co jest w œrodku?
*/

create table abc as select ....

drop table tymczas4;

create global temporary table dupa on commit preserve rows as .....
/


create global temporary table raport_tymczas as 
select department_name nazwa_departamentu,count(*) liczba_pracownikow
from employees join departments using(department_Id)
group by department_name;

/

select * from raport_tymczas;

/


create global temporary table raport_tymczas2 on commit preserve rows as 
select department_name nazwa_departamentu,count(*) liczba_pracownikow
from employees join departments using(department_Id)
group by department_name;

/
select * from raport_tymczas2;
select * FROM USER_VIEWS;
/

BEGIN
EXECUTE IMMEDIATE 'CREATE SEQUENCE WHATEVER';
END;
/

SELECT WHATEVER.NEXTVAL FROM DUAL;
/

DECLARE
NAZWA VARCHAR2(4000):='JAS_FASOLA';
BEGIN
EXECUTE IMMEDIATE 'CREATE SEQUENCE '||NAZWA;
END;
/

SELECT JAS_FASOLA.NEXTVAL FROM DUAL;
/

SELECT * FROM USER_DEPENDENCIES WHERE REFERENCED_TYPE='TABLE';

CREATE OR REPLACE PROCEDURE TESTOWA IS
BEGIN
EXECUTE IMMEDIATE 'TO NIE SQL';
END;
/

EXECUTE TESTOWA;
/

/*55.
Napisz procedurê która przez argument dostanie wysokoœæ podwy¿ki i warunki where jako ci¹g tekstowy. Procedura ma daæ 
podwy¿kê pracownikom spelniajacym warunki podane przez argument.
*/

EXECUTE PODWYZKA(1000,'WHERE COMMISSION_PCT IS NOT NULL');


/


CREATE OR REPLACE PROCEDURE PODWYZKA(ILE NUMBER,WARUNKI VARCHAR2) IS 
S VARCHAR2(4000):='UPDATE EMPLOYEES SET SALARY=SALARY+'||ILE||' '||WARUNKI;
BEGIN
DBMS_OUTPUT.PUT_LINE(S);
EXECUTE IMMEDIATE S;
END;
/

DECLARE
X NUMBER;
BEGIN
 EXECUTE IMMEDIATE 'SELECT SUM(sALARY) FROM EMPLOYEES ' INTO X;
 DBMS_OUTPUT.PUT_LINE('X='||X);
END;
/



DECLARE
X NUMBER;
Y NUMBER;
BEGIN
 EXECUTE IMMEDIATE 'SELECT SUM(sALARY),AVG(SALARY) FROM EMPLOYEES ' INTO X,Y;
 DBMS_OUTPUT.PUT_LINE('X='||X);
 DBMS_OUTPUT.PUT_LINE('Y='||Y);
END;
/

/*56.
Napisz funkcjê która zwróci liczbe wierszy z tabeli employees spe³niajacych warunki przekazane przez argument tej funkcji.
*/

CREATE OR REPLACE FUNCTION ILOSC_PRACOWNIKOW(WAR VARCHAR2) RETURN INTEGER IS 
ZAPYTANIE VARCHAR2(4000);
X INTEGER;
BEGIN
ZAPYTANIE:='SELECT COUNT(*) FROM EMPLOYEES '||WAR;
EXECUTE IMMEDIATE ZAPYTANIE INTO X;
RETURN X;
END;
/

SELECT ILOSC_PRACOWNIKOW('WHERE COMMISSION_PCT IS NOT NULL') FROM DUAL;

/*57.
Napisz procedurê która przyjmie przez argument warunki filtracji po tabelce employees. Procedura ma wczytywaæ do zmiennej typu 
rekordowego a nastepnie wypisac na konsoli ilosc pracownikow, srednie zarobki i maksymalne zarobki dla osob spelniajacych warunki filtracji
*/
/
CREATE OR REPLACE PROCEDURE INFO(WARUNKI VARCHAR2) IS
ZAPYTANIE VARCHAR2(4000);
TYPE REKORDOWY IS RECORD(
LICZBA INTEGER,
SREDNIA NUMBER,
MAKSI NUMBER
);
REK REKORDOWY;
BEGIN
ZAPYTANIE:='SELECT COUNT(*),ROUND(AVG(SALARY)),MAX(SALARY) FROM EMPLOYEES '||WARUNKI;
DBMS_OUTPUT.PUT_LINE(ZAPYTANIE);
EXECUTE IMMEDIATE ZAPYTANIE INTO REK;
DBMS_OUTPUT.PUT_LINE(REK.LICZBA);
DBMS_OUTPUT.PUT_LINE(REK.SREDNIA);
DBMS_OUTPUT.PUT_LINE(REK.MAKSI);
END;
/
EXECUTE  INFO('WHERE DEPARTMENT_ID=90');


--PRZERWA DO 10:36

/*58.
Napisz blok anonimowy który korzystajac z sql dynamicznego wczyta wiersz pracownika którego numer zostanie przekazany przez uzytkownika.
Program ma na konsoli wyswietlic imie, nazwisko i numer telefonu odczytanego pracownika.
*/

DECLARE
WIERSZ EMPLOYEES%ROWTYPE;
NP INTEGER:=100;
BEGIN
EXECUTE IMMEDIATE 'SELECT * FROM EMPLOYEES WHERE EMPLOYEE_iD='||NP INTO WIERSZ;
DBMS_OUTPUT.PUT_LINE(WIERSZ.FIRST_NAME);
DBMS_OUTPUT.PUT_LINE(WIERSZ.LAST_NAME);
DBMS_OUTPUT.PUT_LINE(WIERSZ.PHONE_NUMBER);
END;
/



DECLARE
WIERSZ EMPLOYEES%ROWTYPE;
NP INTEGER:=100;
BEGIN
EXECUTE IMMEDIATE 'SELECT * FROM EMPLOYEES WHERE EMPLOYEE_iD=:X AND DEPARTMENT_ID=:Y' INTO WIERSZ USING NP,90;
DBMS_OUTPUT.PUT_LINE(WIERSZ.FIRST_NAME);
DBMS_OUTPUT.PUT_LINE(WIERSZ.LAST_NAME);
DBMS_OUTPUT.PUT_LINE(WIERSZ.PHONE_NUMBER);
END;
/

1;DROP TABLE JAKASTAM;
/
--DBMS_SQL


/

DECLARE
K SYS_REFCURSOR;
WIERSZ EMPLOYEES%ROWTYPE;
BEGIN
OPEN K FOR 'SELECT * FROM EMPLOYEES';
LOOP
EXIT WHEN K%NOTFOUND;
FETCH K INTO WIERSZ;
DBMS_OUTPUT.PUT_LINE(WIERSZ.LAST_NAME);
END LOOP;
CLOSE K;
END;
/




DECLARE
K SYS_REFCURSOR;
TYPE REKORDOWY IS RECORD(
    NAZWISKO VARCHAR2(4000),
    IMIE VARCHAR2(4000)    
);
REK REKORDOWY;
BEGIN
OPEN K FOR 'SELECT LAST_NAME,FIRST_NAME FROM EMPLOYEES';
LOOP
EXIT WHEN K%NOTFOUND;
FETCH K INTO REK;
DBMS_OUTPUT.PUT_LINE(REK.NAZWISKO||' '||REK.IMIE);
END LOOP;
CLOSE K;
END;
/



DECLARE
K SYS_REFCURSOR;
TYPE REKORDOWY IS RECORD(
    NAZWISKO VARCHAR2(4000),
    IMIE VARCHAR2(4000)    
);
REK REKORDOWY;
TYPE TABLICA IS TABLE OF REKORDOWY INDEX BY BINARY_INTEGER;
TAB TABLICA;
BEGIN
OPEN K FOR 'SELECT LAST_NAME,FIRST_NAME FROM EMPLOYEES';
FETCH K BULK COLLECT INTO TAB;
CLOSE K;
FOR X IN TAB.FIRST..TAB.LAST LOOP
    DBMS_OUTPUT.PUT_LINE(TAB(X).NAZWISKO||' '||TAB(X).IMIE);
END LOOP;
END;
/

/*59.
 Korzystajac z kursora dynamicznego pobierz i wyswietl na konsoli nazwiska i nazwy departamentów wszystkich pracowników.
*/

DECLARE
K SYS_REFCURSOR;
TYPE REKORDOWY IS RECORD(
    POLE1 VARCHAR2(4000),
    POLE2 VARCHAR2(4000)
);
REK REKORDOWY;
BEGIN
OPEN K FOR 'SELECT LAST_NAME, DEPARTMENT_NAME FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID)';
    LOOP
    EXIT WHEN K%NOTFOUND;
    FETCH K INTO REK;
    DBMS_OUTPUT.PUT_LINE(REK.POLE1||' '||REK.POLE2);
    END LOOP;
CLOSE K;
END;
/



DECLARE
K SYS_REFCURSOR;
TYPE REKORDOWY IS RECORD(
    POLE1 VARCHAR2(4000),
    POLE2 VARCHAR2(4000)
);
TYPE TABLICA IS TABLE OF REKORDOWY INDEX BY BINARY_INTEGER;
TAB TABLICA;
BEGIN
OPEN K FOR 'SELECT LAST_NAME, DEPARTMENT_NAME FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID)';
    FETCH K BULK COLLECT INTO TAB;    
CLOSE K;
FOR X IN TAB.FIRST..TAB.LAST LOOP
    DBMS_OUTPUT.PUT_LINE(TAB(X).POLE1||' '||TAB(X).POLE2);
END LOOP;
END;
/

DECLARE
K SYS_REFCURSOR;
TYPE REKORDOWY IS RECORD(
    POLE1 VARCHAR2(4000),
    POLE2 VARCHAR2(4000)
);
TYPE TABLICA IS TABLE OF REKORDOWY INDEX BY BINARY_INTEGER;
TAB TABLICA;
BEGIN
OPEN K FOR 'SELECT LAST_NAME, NULL FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID)';
--OPEN K FOR 'SELECT LAST_NAME, EMPLOYEE_ID FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID)';
--OPEN K FOR 'SELECT LAST_NAME, DEPARTMENT_NAME FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID)';
    FETCH K BULK COLLECT INTO TAB;    
CLOSE K;
FOR X IN TAB.FIRST..TAB.LAST LOOP
    DBMS_OUTPUT.PUT_LINE(TAB(X).POLE1||' '||TAB(X).POLE2);
END LOOP;
END;
/

/*60.
Napisz procedurê która bêdzie wyœwietla³a na konsoli listê numerów pracowników, imion i nazwisk osób spe³niaj¹cych 
warunki podane przez argument procedury. Dane wczytaj za pomoc¹ sql dynamicznego.
*/

create or replace procedure cwiczenie60(warunki varchar2) is 
k sys_refcursor;
type rekordowy is record(
    p1 varchar2(4000),
    p2 varchar2(4000),
    p3 varchar2(4000)
);
rek rekordowy;
begin
open k for 'select employee_id,first_name,last_name from employees '||warunki;
loop
exit when k%notfound;
fetch k into rek;
dbms_output.put_line(rek.p1||' '||rek.p2||' '||rek.p3);
end loop;
close k;
end;
/
execute cwiczenie60('where department_id=50');

--przerwa do 11:41


select * from user_source;
/

select * from user_plsql_object_settings;
alter session set plsql_code_type=native;
alter session set plsql_code_type=interpreted;
alter trigger abc_trigger compile;
alter procedure add_job_history compile;
alter package cwiczenie35 compile;
/

/*61.
Stwórz procedurê która przekompiluje wszystkie posiadane przez Ciebie 
jednostki programowe do trybu natywnego. S³ownik zawieraj¹cy listing wszystkich jednostek
programowych pl/sql: user_plsql_object_settings. Pomiñ kompilacjê elementów typu 
package body i type oraz procedury któr¹ w³aœnie tworzysz.
*/
--SQLERRM
--SQLCODE

CREATE OR REPLACE PROCEDURE KOMPILACJA_NATYWNA IS 
CURSOR K IS 
SELECT * FROM USER_PLSQL_OBJECT_SETTINGS WHERE TYPE NOT IN ('PACKAGE BODY','TYPE') AND NAME<>'KOMPILACJA_NATYWNA';
ZAP VARCHAR2(4000);
BEGIN
EXECUTE IMMEDIATE 'ALTER SESSION SET PLSQL_CODE_TYPE=NATIVE';
FOR W IN K LOOP
    BEGIN
        ZAP:='ALTER '||W.TYPE||' '||W.NAME||' COMPILE';
        DBMS_OUTPUT.PUT_LINE('OK: '||ZAP);
        EXECUTE IMMEDIATE ZAP;
    EXCEPTION
        WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('!!!!! B£¥D: '||ZAP);
    END;
END LOOP;
END;
/

EXECUTE KOMPILACJA_NATYWNA;
SELECT * FROM USER_PLSQL_OBJECT_SETTINGS;
/


--PRZERWA OBIADOWA DO 13:03

CREATE OR REPLACE PROCEDURE ODDAJ(A OUT INTEGER,B OUT VARCHAR2) IS 
BEGIN
A:=1;
B:='COSTAM';
END;
/ 

DECLARE
PARAM1 INTEGER;
PARAM2 VARCHAR2(4000);
BEGIN
ODDAJ(PARAM1,PARAM2);
DBMS_OUTPUT.PUT_LINE(PARAM1);
DBMS_OUTPUT.PUT_LINE(PARAM2);
END;
/


CREATE OR REPLACE PROCEDURE ODDAJ(A OUT INTEGER,B OUT VARCHAR2) IS 
BEGIN
DBMS_OUTPUT.PUT_LINE('W ŒRODKU A: '||A);
DBMS_OUTPUT.PUT_LINE('W ŒRODKU B: '||B);
A:=1;
B:='COSTAM';
END;
/ 

DECLARE
PARAM1 INTEGER:=0;
PARAM2 VARCHAR2(4000):='USTAWIONE';
BEGIN
ODDAJ(PARAM1,PARAM2);
DBMS_OUTPUT.PUT_LINE(PARAM1);
DBMS_OUTPUT.PUT_LINE(PARAM2);
END;
/


CREATE OR REPLACE PROCEDURE ODDAJ(A IN OUT INTEGER,B IN OUT VARCHAR2) IS 
BEGIN
DBMS_OUTPUT.PUT_LINE('W ŒRODKU A: '||A);
DBMS_OUTPUT.PUT_LINE('W ŒRODKU B: '||B);
A:=1;
B:='COSTAM';
END;
/ 

DECLARE
PARAM1 INTEGER:=0;
PARAM2 VARCHAR2(4000):='USTAWIONE';
BEGIN
ODDAJ(PARAM1,PARAM2);
DBMS_OUTPUT.PUT_LINE(PARAM1);
DBMS_OUTPUT.PUT_LINE(PARAM2);
END;
/

--PLIK.READ_LINE(WSKAZNIK_DO_PLIKU,LINE);

/*62.
Stwórz procedurê która przez trzy parametry typu out zwróci srednie zarobki, sumê zarobków i nazwê departamentu
którego numer zostanie podany przez czwarty argument. Przetestuj dzia³anie procedury.
*/

CREATE OR REPLACE PROCEDURE CW62(SREDNIA OUT NUMBER,SUMA OUT NUMBER, NAZWA OUT VARCHAR2,DID INTEGER) IS 
BEGIN
SELECT AVG(sALARY),SUM(SALARY),DEPARTMENT_NAME 
INTO SREDNIA,SUMA,NAZWA
FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID)
WHERE DEPARTMENT_ID=DID
GROUP BY DEPARTMENT_NAME;
END;

/
DECLARE
A NUMBER;
B NUMBER;
C VARCHAR2(4000);
BEGIN
CW62(A,B,C,90);
DBMS_OUTPUT.PUT_LINE('SREDNIA: '||A);
DBMS_OUTPUT.PUT_LINE('SUMA: '||B);
DBMS_OUTPUT.PUT_LINE('DEPARTAMENT: '||C);
END;
/

/*63.
 Stwórz procedurê która przyjmie wartoœæ zmiennoprzecinkow¹ przez parametr typu in out i tym samym parametrem
zwróci tê wartoœæ ale zaokr¹glon¹ do 2 miejsc po przecinku. Przetestuj dzia³anie procedury.
*/
/
create or  replace procedure zaokr(x in out number) is 
begin
x:=round(x,2);
end;
/

declare
e number:=10/3;
begin
dbms_output.put_line('przed='||e);
zaokr(e);
dbms_output.put_line('po='||e);
end;
/

create database link chmura 
connect to hr identified by szkolenie_jsystems_2021
using '13.74.139.54/XEPDB1';
/

select * from employees@chmura;

select * from employees@chmura join departments using(department_id);
/

select * from all_directories;

/

declare
plik utl_file.file_type;
begin
plik:=utl_file.fopen('DANE','pliczek.txt','w');
utl_file.put_line(plik,'treœæ');
utl_file.fclose(plik);
end;
/

/*64.
Zapisz do pliku 100 kolejnych linii o treœci "linia numer 1" zwiêkszaj¹c numerek przy ka¿dej linii
*/


declare
plik utl_file.file_type;
begin
plik:=utl_file.fopen('DANE','linie.txt','w');
for x in 1..100 loop
    utl_file.put_line(plik,'linia numer '||x);
end loop;
utl_file.fclose(plik);
end;

/*65.
Zapisz do pliku w formacie CSV ( kolumny rozdzielone œrednikami) listê imion, nazwisk i numerów telefonów z tabeli employees
*/
/
declare
cursor k is select first_name,last_name,phone_number from employees;
plik utl_file.file_type;
begin
plik:=utl_file.fopen('DANE','kontakty.csv','w');
for w in k loop
    utl_file.put_line(plik,w.first_name||';'||w.last_name||';'||w.phone_number);
end loop;
utl_file.fclose(plik);
end;
/

declare
cursor k is select first_name||';'||last_name||';'||phone_number linia from employees;
plik utl_file.file_type;
begin
plik:=utl_file.fopen('DANE','kontakty.csv','w');
for w in k loop
    utl_file.put_line(plik,w.linia);
end loop;
utl_file.fclose(plik);
end;
/


declare
r char(1):=';';
cursor k is select first_name||r||last_name||r||phone_number linia from employees;
plik utl_file.file_type;
begin
plik:=utl_file.fopen('DANE','kontakty.csv','w');
for w in k loop
    utl_file.put_line(plik,w.linia);
end loop;
utl_file.fclose(plik);
end;

--przerwa do 14:37
/

/*66.
Napisz blok anonimowy który dla ka¿dego departamentu w którym pracuje przynajmniej jedna osoba stworzy plik o takiej nazwie jak nazwa departamentu 
z koncowka .csv.
W pliku powinna znajdowac sie lista imion, nazwisk i telefonów  osob z tego departamentu  w formacie CSV.
*/

declare
cursor departamenty is 
select * from departments where department_id in (select department_id from employees);
cursor pracownicy(did integer) is select first_name,last_name,phone_number from employees where department_id=did;
plik utl_file.file_type;
begin
    for d in departamenty loop
        plik:=utl_file.fopen('DANE',D.DEPARTMENT_NAME||'.csv','W');
        for p in pracownicy(d.department_id) loop
        
        end loop;
        UTL_FILE.FCLOSE(PLIK);
    end loop;
end;
